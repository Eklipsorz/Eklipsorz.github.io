<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eklipsorz.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sloth Engineer">
<meta property="og:url" content="https://eklipsorz.github.io/index.html">
<meta property="og:site_name" content="Sloth Engineer">
<meta property="og:description" content="Success is nothing more than a few simple disciplines, practiced every day.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Eklipsorz">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eklipsorz.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sloth Engineer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sloth Engineer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2022/03/18/Twitter-experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/18/Twitter-experience/" class="post-title-link" itemprop="url">Twitter 團體協作體驗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-18 04:10:37 / Modified: 05:37:59" itemprop="dateCreated datePublished" datetime="2022-03-18T04:10:37+08:00">2022-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1647551406/twitter/project/result-index_v3s4l7.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由於學期三的第六週課程就接著推特，而我本身還沒完全吸收完第六週課程，就直接上戰場來挑戰團隊協作，有點像是越等打怪，所以我在團隊協作裡事先與其他隊友達成推特協作的成品要有怎麼樣的完整性，在這裡我們決定以MVP的形式，不添加額外的架構、功能、易容易合作&#x2F;理解的開發風格和架構為優先。另外我也得想辦法從中快速成為即戰力來為整個團隊給予助力。</p>
<h2 id="開發結構"><a href="#開發結構" class="headerlink" title="開發結構"></a>開發結構</h2><p>推特專案是以前後端分離的形式以及搭配資料來進行，其結構分別如下：</p>
<ul>
<li>前端：使用 Vue 框架 + github page建立前端伺服器</li>
<li>後端：使用 Express 框架 + Node.js執行環境 + CORS + Heroku 部署API 伺服器</li>
<li>資料庫：使用sequelize作為MySQL的ORM</li>
</ul>
<h2 id="分工情況-amp-amp-角色"><a href="#分工情況-amp-amp-角色" class="headerlink" title="分工情況 &amp;&amp; 角色"></a>分工情況 &amp;&amp; 角色</h2><p>成員有John、Yu、雍澈、我(orion)，John、Yu負責前端開發，而雍澈和我負責後端開發，在團隊協作裡，我們會按照實際開發狀況來彼此間會擔當不同角色，比如PM、QA、實際開發者，不會指定一些人來擔當職務，所以在這樣的分工狀況，就更需要彼此間的督促、開會、相互幫忙。</p>
<h2 id="過程：開始至Sprint-1"><a href="#過程：開始至Sprint-1" class="headerlink" title="過程：開始至Sprint #1"></a>過程：開始至Sprint #1</h2><p>一開始，大家都相互決定要達成成品的完成度之共識，接著按照AC指定的Sprint#1所需要的規格、人員分工、進度分工、DOD來準備，準備期間真的是手忙腳亂的，尤其是大家都是從別的領域轉過來學習的，所以更加不熟悉準備什麼，好在夥伴們都會相互提醒、幫忙分擔工作，然後透過密集式的會議才勉強把這階段要的資料都備齊以及定義好規格。</p>
<p>備齊之後，就開始進行按照分工來開發，剛開始的後端開發由於我跟雍澈並不像其他同學能夠預先利用時間來準備，所以特別容易緊張，甚至要規定的功能都無法正常產出，而且雍澈那邊也須兼顧著工作，當然，這樣子的合作狀況是不行的，所以我們就用Trello 追蹤後續進度、使用Slack定期回報自己完成什麼事情、相互打氣聊天的形式進行、公開API文件給前端知道假資料如何做。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1647551406/twitter/project/trello-result_bhdhcm.png"></p>
<h2 id="過程：Sprint-1後-至-Sprint-2"><a href="#過程：Sprint-1後-至-Sprint-2" class="headerlink" title="過程：Sprint #1後 至 Sprint #2"></a>過程：Sprint #1後 至 Sprint #2</h2><p>隨著我們改用Trello、Slack等工具來維持進度的追蹤以及相互打氣，我們的開發速度有逐漸提升，但那時候發現負責前端的夥伴實在太強大，已經把前端的切版都作完，只剩下我們這邊的API給的資料以及透過資料所要做的功能開發，這使後端的我們變得異常緊張，所以我們是在這種異常緊張的狀況進行，同時為了讓前端部分不會被後端的開發速度延宕，所幸Yu有提案說先把目前能提供的API部署在Heroku，讓他們能夠同時進行開發以及幫我們後端找出潛在的bug，不然不知道要花多久時間才能部署…..，當然的，這樣開發模式，會變成我跟雍澈得邊輪班除錯和開發或者邊保持待命邊開發其他功能，而且還得根據實際開發的結果來變動到API文件上的格式，並隨時通報自己變動了什麼。</p>
<p>接著就是輪到AC 所指定的Sprinit #2繳交作業，這部分比較像是回報目前開發狀況是如何以及如何安排後續的開發，所以沒像Sprint #1需要很多時間去做準備。</p>
<h2 id="過程：Sprint-2後-至-Sprint-3"><a href="#過程：Sprint-2後-至-Sprint-3" class="headerlink" title="過程：Sprint #2後 至 Sprint #3"></a>過程：Sprint #2後 至 Sprint #3</h2><p>接著就是Sprint #2後 至 Sprint #3的期間，由於伺服器的提前部署，使得前後端能夠在第一時間串接，當然也免不了大量的bug修正和溝通，這時有隊友提議要不要在sprint #3進行showcase來提前讓評審先發現潛在問題，雖說就我而言，我蠻怕在那之前就還沒開發完畢，不過好在有夥伴幫忙分攤後端開發以及前端大大們那可怕的開發能力，讓推特初步功能也在sprint #3前就完成了。</p>
<h2 id="Sprint-3後-至-繳交當天"><a href="#Sprint-3後-至-繳交當天" class="headerlink" title="Sprint #3後 至 繳交當天"></a>Sprint #3後 至 繳交當天</h2><p>經過最後一次的Sprint分享後，我們就做了最後一次的會議來驗收功能、小幅度地修正bug、寫readme、跑一遍readme的流程，並於最後繳交作業，所幸驗收結果是顯示只剩下bug要修正，所以對這些bug進行簡單的排序，看哪邊重要就先改，不重要就先跳過，接著做寫readme和驗證readme流程是否正確，過程中，還有一些前端的bug要修正，但為了怕前端夥伴需要後端來進行溝通，得要有個後端待命，但那時預計修正的時間會偏晚，所以就讓雍澈先睡來應付隔天的上班，我來負責守夜兼確定我們是否有按照DOD完成和尋找潛在bug，守夜到天亮，前端那邊就換班修bug，但後端也只剩下我一個人負責，所以我就堅持到前端隊友繳交成品後才睡覺。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><a target="_blank" rel="noopener" href="https://github.com/JiangShuuu/twitter_project">前端開發repo</a><br><a target="_blank" rel="noopener" href="https://github.com/Yung-Che/twitter-api-2020">後端開發repo</a><br><a target="_blank" rel="noopener" href="https://protected-springs-71103.herokuapp.com/">後端入口DEMO</a>.<br><a target="_blank" rel="noopener" href="https://jiangshuuu.github.io/twitter_project/">專案成品DEMO</a>.<br><a target="_blank" rel="noopener" href="https://simple-twitter-api.gitbook.io/api/HDZXvOJdS0oEs3mTdu7w/">API 文件</a>. </p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這次協作體驗最難的地方是溝通、溝通、溝通，這很重要，所以講了三次，少了溝通，任何協作都無法完成，就結果來說，大家都做得不錯，彼此間都會為了通過而願意密集式溝通和合作，即使身兼全職工作，隊友也都會為了這個團隊盡量請假幫忙協作開發，就進度而言，除了第一個sprint有延宕開發進度以外，後續的協作隨著適應而進而改善許多，同時間還要感謝前端那邊的大大竟然能在短時間完成。XD</p>
<h2 id="還能做的優化"><a href="#還能做的優化" class="headerlink" title="還能做的優化"></a>還能做的優化</h2><p>根據這次的協作體驗下，後端還可以做的優化可以是這些：</p>
<ol>
<li>後端API 在前端發送大量請求下能夠正常執行</li>
<li>部分API過於依賴資料庫的計算，這使得執行成本</li>
<li>錯誤訊息的包裝可以自製一個error物件來打造更適合推特專案的物件，且能夠進一步縮減程式碼和提升功能性</li>
<li>採用swagger 能夠讓API文件跟著實際執行結果而變動</li>
<li>可將重複較高的功能以middleware形式來載入給其他路由</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2022/03/18/AC-graduate-experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/18/AC-graduate-experience/" class="post-title-link" itemprop="url">AC畢業心得：從學期一至學期三</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-18 01:28:19 / Modified: 03:40:50" itemprop="dateCreated datePublished" datetime="2022-03-18T01:28:19+08:00">2022-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我是一名資工人，在進入AC之前，我因為自己的年少輕狂沒在畢業後自己先找好一條未來能求生的道路(當軟體工程師？還是當研究者)，而是跑去和朋友創業和準備博士班的東西，但最後都以不同的失敗形式而告終。隨後的幾個禮拜，我一直沈淪在過去的後悔中，直到我發現自己曾於medium發的演算法文章有被一些人關注，我點開來發現這些人都是AlphaCamp(AC)的學員，且他們都非本科系的條件下成功轉職成軟體工程師。</p>
<p>當下的我覺得自己或許還有機會回過頭好好決定並實現成為一名稱職的工程師，所以我著手一系列的學習計畫想在AC平台學習來轉職成後端工程師，但首先我必須驗證自己還有沒有能力適應程式開發上的邏輯思維，接著就是學習如何在大量資訊中快速學習以及身為junior工程師該要有的思維邏輯以及基礎開發技術。</p>
<h2 id="學期一：-測試自己是否還能適應程式"><a href="#學期一：-測試自己是否還能適應程式" class="headerlink" title="學期一： 測試自己是否還能適應程式"></a>學期一： 測試自己是否還能適應程式</h2><p>在學期一中，我想藉著學習內容來驗證自己還有沒有能力適應程式開發上的邏輯思維，本來我想如果這目標無法達成，可能就得想一想如何改進或者放棄，但過程卻讓我始料未及，課程上所教的網頁開發和實際所做的練習竟然讓我慢慢找回當初喜歡程式的感覺，我憑藉著這份感覺進一步學習問題如何被拆解？如何逐一解決？然後合併成一個完整的解法？ 最後很順利地完成這學期的課程。</p>
<h2 id="學期二：-學習如何學新技術"><a href="#學期二：-學習如何學新技術" class="headerlink" title="學期二： 學習如何學新技術"></a>學期二： 學習如何學新技術</h2><p>在學期二中分成三個階段，難度會隨著階段數而提升，然而我也發覺自己喜歡研究的個性讓我在這個學期挖了不少坑並費了心思去做深入學習和進度的取捨Orz，當然，這份個性幫助我如何用HTML、CSS、JS開發一個好的成品，從如何實作AC 校長盃 UI到事件處理的過程中，深入學習到如何手刻實作以及事件處理在瀏覽器所會有的實現。</p>
<p>面對接下來的挑戰難度提高，當時的我認為肯定深入很多課題而挖坑，而坑也因為難度跟著提升而難以填坑，所以我就想辦法預先學習下一個階段的內容，然後在我每一次要做之前，為了適當運用這份個性，都要告訴自己只能深入研究的課題難度到哪以及太超過的話該如何處置，比如做todolist時，就只能將成品做到可拖曳每個項目，不能夠進一步做成Trello那樣，點開每一個項目都能看到項目描述和待做清單<br><a target="_blank" rel="noopener" href="https://codepen.io/orionxd52/pen/qBXZVdr">作品連結</a></p>
<p>學期二的最後階段，我選擇了後端課程，這才正式踏入後端開發的領域，剛開始接觸一大堆從沒聽說過的術語、工具名詞，面對這些難題，我選擇邊做邊思考這些術語和工具在整個專案中擔當什麼樣的角色以及它具有的用途是什麼，不過由於內容過多，最終我把能夠預先學習下個學期三的時間都投資在這塊，也盡可能不再深入太多艱難課題，只是將課題記錄下來，待到之後有時間就來好好學習並替自己解答。</p>
<p>在完成學期二的最後一個作業時，我一直在思考著我能否在學期三跟得上進度，畢竟我很容易花很多時間去研究深入課題，而忽視進度，甚至有到想放棄這個學期，到下個學期學習的想法，不過最終我選擇挑戰，既然有可能會無法趕上進度，那麼我就更要去做 <strong>如何在有時間壓力的情況下，及時學習和運用</strong> 的刻意練習來強化。</p>
<h2 id="學期三：-以軟體工程師思考開發"><a href="#學期三：-以軟體工程師思考開發" class="headerlink" title="學期三： 以軟體工程師思考開發"></a>學期三： 以軟體工程師思考開發</h2><p>在這個學期中，我已經沒多少可以預先學習的時間，只能跟著一週又一週來往前進，不過我發覺到在這個學期學到的內容都因為前面學期的深入研究而變得更容易了解以及如何運用，沒到想象中會更有時間壓力去進行，只是作業所涉及到的層面就更廣更需要時間去做開發，主要時間都花在實作上和觀摩助教如何以工程師去思考如何開發一個好的專案。</p>
<p>不過直到接觸第四、五週的內容，就踏入一個我從未認真碰過的領域-測試、Travis、Pull Request，剛開始做都要稍微觀摩同學們是如何做以及如何面對測試和Travis帶來的挑戰，痛苦但卻覺得值得學習，因為這樣子的練習可使人做出符合出規格的專案，甚至是MVP，而非把作業當作自己的作品來做，對於我來說，這份練習是相對珍貴和給予我一些 <strong>如何在有時間壓力的情況下，及時學習和運用</strong> 的刻意練習機會</p>
<p>最後順利到了第六週的API伺服器課程內容，內容更加偏向於後端工程師所要做的事情，同時也是推特比賽所會用到的主要技術，我為了能夠幫助自己和隊友通過推特比賽，而想辦法多弄出一些時間來學習這週內容，能學多少就學多少，所幸這份努力以助力的形式已成功通過推特比賽。 </p>
<h2 id="整體感想"><a href="#整體感想" class="headerlink" title="整體感想"></a>整體感想</h2><p>在AC的學習之旅中，過程是既覺得痛苦但卻覺得很踏實很值得，畢竟平台給予足夠的時間壓力和內容來幫助我朝著正確方向去推進，而且過程中還有不少助教、導師、教練、社群帶來的鼓勵來幫助我度過最難過的時期，如果換作是其他平台，或許就沒辦法有這樣子的成果，我很感謝AC平台。</p>
<p>但這個旅程的結束並非代表著我的程式人生就結束，這只是轉職的一小塊拼圖，我還有許多要深入的開發課題要做以及憑著這份經驗來轉職成我原本無法做出決定的軟體工程師。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/12/13/self-study-experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/self-study-experience/" class="post-title-link" itemprop="url">AC平台的自學經驗回顧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-13 23:07:06" itemprop="dateCreated datePublished" datetime="2021-12-13T23:07:06+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:36" itemprop="dateModified" datetime="2022-03-18T00:06:36+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引發自學的問題"><a href="#引發自學的問題" class="headerlink" title="引發自學的問題"></a>引發自學的問題</h2><p>根據AC平台給予的餐廳平台開發規格來開發其平台的過程中，令我最頭痛的問題就是如何解決以下問題，而這也是這篇文章的開端。</p>
<blockquote>
<p>使用者在點選刪除按鈕，要有提示視窗提示使用者確定是否刪除，等使用者按下確定刪除才會真的刪除</p>
</blockquote>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1639406983/self-study-experience/example_weayrt.gif" alt="示意圖"></p>
<p>首先刪除按鈕原本是被一個表單元件所包覆著，而按鈕就是內部的按鈕元件，一般來說當使用者按下刪除按鈕，表單會發生提交事件並做預設事件處理，以POST的方式來轉交資料指定位置至以及導向其指定位置，而我設定的指定位置則是伺服器的合法路由，如下所示：</p>
<blockquote>
<p>&#x2F;restaurants&#x2F;?_method&#x3D;DELETE</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/restaurants/&#123;&#123; this._id &#125;&#125;?_method=DELETE&quot; class=&quot;delete-form&quot; method=&quot;post&quot; data-name=&quot;&#123;&#123;this.name&#125;&#125;&quot; style=&quot;display: inline;&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger&quot;&gt;Delete&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>而伺服器當接收到該路由的請求，便會根據路由清單找尋合適的路由來做處理，而這個路由處理的內容如下，主要是根據使用者按下的刪除按鈕之ID來刪除對應的餐廳資料以及重新導向瀏覽所有餐廳的首頁，所以在不做任何處理的情況下，只要刪除按鈕被按下，就會被刪除並重新渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// define route for deleting a restaurant</span><br><span class="line">router.delete(&#x27;/:id&#x27;, (req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const reqId = req.params.id</span><br><span class="line"></span><br><span class="line">  // find the restaurant by id and delete it</span><br><span class="line">  restaurantModel.findByIdAndRemove(reqId)</span><br><span class="line">    .exec()</span><br><span class="line">    .then(() =&gt; res.redirect(&#x27;/&#x27;))</span><br><span class="line">    .catch((error) =&gt; console.log(error))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而<strong>提示視窗的發生必須發生在點擊刪除時才發生，且不能在使用者按下確定之前或者按下取消就刪除餐廳，必須等到使用者按下確定刪除才可刪除</strong>，所以在這裡必須先取消掉表單的預設提交事件處理，讓它在發生提交事件的時候能夠在出現提示視窗的時候能夠不刪除，且等著使用者按下確定，在這裏我使用著sweetalert 2所提供的API來實現著提示視窗和能夠等著使用者按下確定的機制，並放置在表單的提交事件內部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// fire a event to swal for showing alert model</span><br><span class="line">    Swal.fire(&#123;</span><br><span class="line">      title: `確定移除$&#123;restaurantName&#125;嗎？`,</span><br><span class="line">      showDenyButton: true,</span><br><span class="line">      confirmButtonText: &#x27;確定移除&#x27;,</span><br><span class="line">      denyButtonText: &#x27;取消移除&#x27;,</span><br><span class="line">    &#125;).then((result) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      // If user click a button for confirming, it just send a request for deleting it</span><br><span class="line">      if (result.isConfirmed) &#123;</span><br><span class="line">        Swal.fire(&#x27;已移除&#x27;, &#x27;&#x27;, &#x27;success&#x27;)</span><br><span class="line">      &#125; else if (result.isDenied) &#123;</span><br><span class="line">        // If user click a button for cancelling, it just cancel execution of deleting it</span><br><span class="line">        Swal.fire(&#x27;別擔心，我沒移除喔 :&gt;&#x27;, &#x27;&#x27;, &#x27;info&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>而整體的表單事件會是如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">deleteForm.addEventListener(&#x27;submit&#x27;, (event) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">   const restaurantName = deleteForm.dataset.name</span><br><span class="line"></span><br><span class="line">   // fire a event to swal for showing alert model</span><br><span class="line">   Swal.fire(&#123;</span><br><span class="line">     title: `確定移除$&#123;restaurantName&#125;嗎？`,</span><br><span class="line">     showDenyButton: true,</span><br><span class="line">     confirmButtonText: &#x27;確定移除&#x27;,</span><br><span class="line">     denyButtonText: &#x27;取消移除&#x27;,</span><br><span class="line">   &#125;).then((result) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">     // If user click a button for confirming, it just send a request for deleting it</span><br><span class="line">     if (result.isConfirmed) &#123;</span><br><span class="line">       Swal.fire(&#x27;已移除&#x27;, &#x27;&#x27;, &#x27;success&#x27;)</span><br><span class="line">       // send a data to /restaurants/:id/delete via post method and redirect to /</span><br><span class="line">       deleteForm.submit()</span><br><span class="line"></span><br><span class="line">     &#125; else if (result.isDenied) &#123;</span><br><span class="line">       // If user click a button for cancelling, it just cancel execution of deleting it</span><br><span class="line">       Swal.fire(&#x27;別擔心，我沒移除喔 :&gt;&#x27;, &#x27;&#x27;, &#x27;info&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第一次出手與失敗"><a href="#第一次出手與失敗" class="headerlink" title="第一次出手與失敗"></a>第一次出手與失敗</h2><p>在這裡為了解決以下問題，</p>
<blockquote>
<p>提示視窗的發生必須發生在點擊刪除時才發生，且不能在使用者按下確定之前或者按下取消就刪除餐廳，必須等到使用者按下確定刪除才可刪除</p>
</blockquote>
<p>首先我從preventDefault和stopPropagation的角度來取消瀏覽器給予的預設提交事件處理，並將語法放在sweetalert的API之前，想先取消掉，結果真的如預期般的，當使用者按下刪除按鈕跑出視窗時，瀏覽器再也不會隨意提交資料和導向頁面，只是<strong>問題轉變成我要如何透過語法自行提交資料</strong>，好觸發伺服器對應路由。</p>
<p>過程中，我是有做出一些傻事，比如將上述語法放入至sweetalert的特定區塊(下面程式碼的最後兩行)，而這特定區塊是負責定義”被按下取消所要做的處理”，想說按下確定就按照原有預設的事件處理，而按下取消就取消掉好避免額外的刪除，但由於preventDefault這語法本身必須要在第一時間告知瀏覽器取消原有事件處理，若拖到告知的時間，就會使該語法的功用失效，而我是放在swal所建立的promise後的then，而這樣的放置勢必會拖到第一時間告知的時間，進而讓表單正常使用預設的事件處理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Swal.fire(&#123;</span><br><span class="line">     title: `確定移除$&#123;restaurantName&#125;嗎？`,</span><br><span class="line">     showDenyButton: true,</span><br><span class="line">     confirmButtonText: &#x27;確定移除&#x27;,</span><br><span class="line">     denyButtonText: &#x27;取消移除&#x27;,</span><br><span class="line">   &#125;).then((result) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">     // If user click a button for confirming, it just send a request for deleting it</span><br><span class="line">     if (result.isConfirmed) &#123;</span><br><span class="line">       Swal.fire(&#x27;已移除&#x27;, &#x27;&#x27;, &#x27;success&#x27;)</span><br><span class="line">     &#125; else if (result.isDenied) &#123;</span><br><span class="line">       // If user click a button for cancelling, it just cancel execution of deleting it</span><br><span class="line">       Swal.fire(&#x27;別擔心，我沒移除喔 :&gt;&#x27;, &#x27;&#x27;, &#x27;info&#x27;)</span><br><span class="line">       event.preventDefault()  //  &lt;- 放在這喔</span><br><span class="line">       event.stopPropagation() //  &lt;- 放在這喔</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="尋找與嘗試"><a href="#尋找與嘗試" class="headerlink" title="尋找與嘗試"></a>尋找與嘗試</h2><p>後來想到表單在接受瀏覽器的解析後勢必會像物件那樣擁有屬性和方法，那時我就在想或許表單擁有著類似可以自己提交的功能，後來查閱了MDN和w3school，果不其然，表單的確有名為submit的方法可以讓使用者決定何時提交表單資料，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">form.submit()</span><br></pre></td></tr></table></figure>
<p>我將取消預設事件處理的程式碼放到sweetalert 2的API之前，然後在sweetalert的另一塊負責定義使用者按下確定的處理內容添加上述語法，整體表單提交事件處理的程式碼會是如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">deleteForm.addEventListener(&#x27;submit&#x27;, (event) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  event.preventDefault()</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">  const restaurantName = deleteForm.dataset.name</span><br><span class="line"></span><br><span class="line">  // fire a event to swal for showing alert model</span><br><span class="line">  Swal.fire(&#123;</span><br><span class="line">    title: `確定移除$&#123;restaurantName&#125;嗎？`,</span><br><span class="line">    showDenyButton: true,</span><br><span class="line">    confirmButtonText: &#x27;確定移除&#x27;,</span><br><span class="line">    denyButtonText: &#x27;取消移除&#x27;,</span><br><span class="line">  &#125;).then((result) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // If user click a button for confirming, it just send a request for deleting it</span><br><span class="line">    if (result.isConfirmed) &#123;</span><br><span class="line">      Swal.fire(&#x27;已移除&#x27;, &#x27;&#x27;, &#x27;success&#x27;)</span><br><span class="line">      // send a data to /restaurants/:id/delete via post method and redirect to /</span><br><span class="line">      deleteForm.submit()</span><br><span class="line"></span><br><span class="line">    &#125; else if (result.isDenied) &#123;</span><br><span class="line">      // If user click a button for cancelling, it just cancel execution of deleting it</span><br><span class="line">      Swal.fire(&#x27;別擔心，我沒移除喔 :&gt;&#x27;, &#x27;&#x27;, &#x27;info&#x27;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>修改後並做了測試來確定以下的事情是否成功，結果是成功的。</p>
<blockquote>
<p>提示視窗的發生必須發生在點擊刪除時才發生，且不能在使用者按下確定之前或者按下取消就刪除餐廳，必須等到使用者按下確定刪除才可刪除</p>
</blockquote>
<p>不過由於刪除表單不只一個，所以用上了以下語法來包覆著上面的語法，來讓每個餐廳的刪除按鈕都擁有相同的事件處理內容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const deleteForms = document.querySelectorAll(&#x27;.delete-form&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// add sumbit event to each form (button) for deleting</span><br><span class="line">// when occuring submit event, it just showing another alert model </span><br><span class="line">// to remind user to make sure that each user really want to delete</span><br><span class="line">deleteForms.forEach(deleteForm =&gt; &#123;</span><br><span class="line">    ///.... </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="回顧與發現"><a href="#回顧與發現" class="headerlink" title="回顧與發現"></a>回顧與發現</h2><p>從結果來回顧過去所做的事情，雖然看似很簡單，但其實我花了不少時間去研究表單提交的機制以及有什麼樣的方法，只是在這裡不會太探討那些細節，我還去研究form在html語法下會有的屬性(attribute)，如onsubmit要放置return false，但不管如何，這些過程也幫助我理解表單這物件會有什麼方法能夠使用以及如何搭配著類似sweetalert2這樣子提示視窗來解決我原有的問題。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/11/27/prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/27/prototype/" class="post-title-link" itemprop="url">JavaScript 的 prototype 簡介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-27 20:24:48" itemprop="dateCreated datePublished" datetime="2021-11-27T20:24:48+08:00">2021-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:36" itemprop="dateModified" datetime="2022-03-18T00:06:36+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="object-oriented-language"><a href="#object-oriented-language" class="headerlink" title="object oriented language"></a>object oriented language</h2><p>一個軟體的開發過程若都經由人類決定以及執行的話，那麼遲早會為了加速軟體的開發效率，而讓軟體的開發方式易於人類理解和使用，而物件導向語言正是其中一個案例，以易於人類理解的物件概念來建構出一項語言，在使用這項語言中會以物件(object)為一個開發上的基本單位，換言之，所有的程式碼皆會以物件本身來開發。</p>
<p>這個語言中，定義了物件本會有的性質：</p>
<ul>
<li>一個物件都如同世界上的每一個物件那樣，具有能夠進一步描述自己的屬性(property)以及進一步描述自己能做些什麼事情的方法(method)</li>
<li>物件和物件存在著某種關係使其中一個物件擁有(繼承)另一個物件所擁有的屬性和方法，進而使物件們在屬性和方法很相似，比如兩個物件因為親子關係，擔任兒子的物件會繼承父母的物件所擁有的屬性和方法</li>
<li>物件和物件不存在某種關係來使其中一個物件擁有(繼承)另一個物件所擁有的屬性和方法，而是在屬性和方法上可以統一成一個物件來分類，換言之就是以同種性質的物件但卻額外以不同形式、外型、結構來衍生出多個同性質且不同外形的物件，比如鳥和魚可以統一成一個物件</li>
</ul>
<p>而對於以上性質的實現，程式語言上主要有三種實現概念分別對應它們：</p>
<ul>
<li>Encapsulation：將程式碼以物件為軟體開發的基本單位來進行分類封裝，而每一個物件下所擁有的屬性和方法都皆封裝了對應的實作程式碼，進而讓開發方式都以物件來著手</li>
<li>Inheritance：允許物件A可以從而繼承(擁有)另一個物件B所擁有的屬性和方法，而物件A本身也可以擁有自己本身的屬性和方法</li>
<li>Polymorphism：允許多個物件整合成一個同種性質(某些屬性和方法相同的)的物件A，而物件A藉由相同性質以及附加額外屬性和方法來衍生多個物件們</li>
</ul>
<p>不過實際上來說， 雖說Inheritance 和 Polymorphism 在概念上有些許的不同，但如果從實現他們的角度來看，這兩種都能從另一個類別A獲取相同的屬性名和方法名，只是唯一的差別就在於Polymorphism所對應的屬性值和方法值會是以不同於類別A的形式來存在，</p>
<blockquote>
<p>Polymorphism是描述同種性質的東西可以以不同形式、外形、結構來呈現&#x2F;存在，比如同屬於動物的東西可以以有翅膀、有魚鰭、有爪子的形式來存在</p>
</blockquote>
<p>因此可以將這兩個概念在獲取相同的屬性名和方法名或者定義繼承關係上實作成同一個機制，然後在對應屬性值和方法值這兩個賦予方式分別做出不同的機制來滿足他們原有的概念。</p>
<p>最後由於軟體開發上是以物件為基本單元來開發，但電腦是無法直接辨識物件以及不知道如何實作物件背後的屬性和方法，因此必須事先告知電腦物件是什麼的概念，而根據程式語言是否為直譯或者編譯來區分成兩種主要方法：</p>
<ul>
<li>class-based：通常僅限於編譯語言，在編譯時期是先以類別來定義每一個物件是什麼樣子、具有哪些屬性和方法、與其他物件又具有什麼關係，執行時期則是按照具體定義&#x2F;類別來執行。</li>
<li>prototype-based：通常僅限於直譯語言，由於不存在編譯時期，所以並沒辦法更早一步去定義物件，只能在執行期間產生出代表物件概念X的實體物件，而這個實體正是原型機(prototype，可藉由其本身來慢慢演進成對應物件的原型物件)，而該實體可藉由執行過程中添加屬性和方法來慢慢讓這個物件成形，並且允許每個物件都相關的屬性值來物件所屬的物件概念，從而實現定義物件的繼承，過程中，可能會使用物件的deep copy來實現Inheritance和Polymorphism，以避免多個物件共享於同一個參照或者同一個記憶體區塊。</li>
</ul>
<p>參考資料：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/816071/prototype-based-vs-class-based-inheritance">prototype based vs. class based inheritance</a></p>
<h2 id="JavaScript-物件導向"><a href="#JavaScript-物件導向" class="headerlink" title="JavaScript 物件導向"></a>JavaScript 物件導向</h2><ol>
<li>JavaScript 由於本身是直譯語言，只能以ProtoType-based 風格來實現物件導向這概念，但後來為了讓更多人適應JS而在ES2015之後提供class這關鍵字，但實際上只是被封裝後的語法糖(Syntactic Sugar)，其本質仍為ProtoType-based</li>
</ol>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>prototype 的 原意是為了實現某些概念或想法而實做出來的第一個實體物，而往後的開發或者進展將會以該實體物為主，在這裡是以實現某些物件概念的第一個實體物件，本身會是定義這個物件概念擁有的屬性和方法，任意物件都擁有著prototype這屬性，而這屬性正是指定這物件是屬於哪一種物件概念，而屬性值會是代表該物件概念的實體物件，當任意物件透過prototype去指定任意一個物件概念，就能擁有(共享)該物件概念所擁有的屬性和方法，如物件1的prototype設定為物件2的prototype，那麼這兩個物件就能擁有(共享)同一個物件概念所擁有的屬性和方法，prototype屬性的設定方法：<br>    - 當透過new方法時，就會按照constructor綁定的prototype來設定<br>    - 直接透過prototype屬性值來設定</p>
<h3 id="prototype-定義"><a href="#prototype-定義" class="headerlink" title="prototype 定義"></a>prototype 定義</h3><p>然而實際上prototype在概念上仍屬於實體物件，本質上仍需要額外內容來定義prototype具體所擁有的屬性和方法，當有了prototype具體的定義之後，就能依據其定義來建構出代表物件概念的prototype實體，而JS具體定義prototype所擁有的屬性和方法是透過函式和函式名稱來實現，函式名稱代表著prototype的名稱，而函式本身為該prototype的constructor - 負責建立對應prototype實體物件的函式，其中key為屬性或者方法，而value可以填入原型、物件、函式等，該函式若是以constructor形式來執行，會回傳一個prototype名為prototype1的物件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function prototype1 () &#123;</span><br><span class="line">  this.key1 = value1</span><br><span class="line">  this.key2 = value2</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prototype-例子"><a href="#prototype-例子" class="headerlink" title="prototype 例子"></a>prototype 例子</h3><p>假設要定義一個名為person的prototype，在這個定義中會有名字和電子郵件，那麼內容會是如下，當person被當作以constructor形式來執行時，就回傳一個prototype名為person的物件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function person (name, email) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.email = email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="透過prototype來建立實體"><a href="#透過prototype來建立實體" class="headerlink" title="透過prototype來建立實體"></a>透過prototype來建立實體</h3><p>JavaScript允許開發者使用new關鍵字和代表prototype的函式來建立符合prototype的實體物件，在這裡的new會建立一個空實體物件，接著設定該物件的__proto__屬性為對應的prototype(new關鍵字之後的prototype名稱)，並將該空實物物件和value1, value2,… 等參數傳入至function prototype1 ()，而傳入進去的空實體物件在函式會是由this變數來儲存，在這裡會定義著該實體物件會有哪些新的屬性和方法，並按照指示將value1, value2,… 傳入至對應的新屬性和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function prototype1 (value1, value2, ....) &#123;</span><br><span class="line">  this.key1 = value1</span><br><span class="line">  this.key2 = value2</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance = new prototype1(value1, value2, ....)</span><br></pre></td></tr></table></figure>

<p>另外JavaScript對於prototype的建構式的引數和參數之間的數量給予一定的彈性，不必兩者的數量一致就能允許執行，會按照對應位置來將引數對應至參數，而沒配到對的參數或者引數，會按照預設行為來處置，若有參數沒配到引數的話，其參數會被設定成undefined，而引數沒配到參數的話，就當即跳過。</p>
<p>題外話：此時若該實體物件是該prototype的第一個實體物件，那麼該實體就即可代表著prototype。</p>
<h3 id="例子：透過prototype來建立實體"><a href="#例子：透過prototype來建立實體" class="headerlink" title="例子：透過prototype來建立實體"></a>例子：透過prototype來建立實體</h3><p>首先定義一個名為Employee的Prototype建構式，並試著用new和Prototype建構式來建立參數和引數數目不同的情況，一開始會沒給定引數(沒加括號)，接著給予空引數，緊接著給一個引數，這個動作會持續到增加第四個引數，其結果來看的話，沒給定引數會跟給予空引的結果都皆為沒給定對應的引數而讓參數為undefined，而給予一個引數的情況則是讓第一個參數有了配對而除他以外的參數皆為undefined，給予兩個引數，則都沒顯示undefined，若給予多於參數數量的引數，則會跟給予合適引數的情況一樣，每個參數都沒undefined，只是額外的引數會當即跳過。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Employee(name, dept) &#123;</span><br><span class="line">	this.name = name</span><br><span class="line">	this.dept = dept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Employee())</span><br><span class="line">console.log(new Employee)</span><br><span class="line">console.log(new Employee(&#x27;sloth&#x27;))</span><br><span class="line">console.log(new Employee(&#x27;sloth&#x27;, &#x27;test&#x27;))</span><br><span class="line">console.log(new Employee(&#x27;sloth&#x27;, &#x27;test&#x27;, &#x27;test1&#x27;))</span><br><span class="line">console.log(new Employee(&#x27;sloth&#x27;, &#x27;test&#x27;, &#x27;test1&#x27;, &#x27;test2&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637945033/blog/prototype/newInstanceExample_dv9x64.png"></p>
<h3 id="Object-prototype-屬性移除-x2F-增加"><a href="#Object-prototype-屬性移除-x2F-增加" class="headerlink" title="Object.prototype 屬性移除&#x2F;增加"></a>Object.prototype 屬性移除&#x2F;增加</h3><p>在JavaScript中可以在執行過程對特定原型進行屬性&#x2F;方法上的增加和移除，通常增加方式為以下形式，其中constructor為作為原型定義的建構函式，prototype則是指constructor所擁有的原型物件，key則是該原型物件的屬性，而value就是對應值，由此來對特定屬性來填入任意值或者任意物件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor.prototype.key = value</span><br></pre></td></tr></table></figure>

<p>而移除方式為以下形式，其中delete為刪除特定屬性的關鍵字，而constructor.prototype則是指建構函式所擁有的原型物件，key則是該物件上的屬性，由此來刪掉特定屬性(含屬性值)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete constructor.prototype.key</span><br></pre></td></tr></table></figure>

<h2 id="prototype-實作繼承方式"><a href="#prototype-實作繼承方式" class="headerlink" title="prototype 實作繼承方式"></a>prototype 實作繼承方式</h2><h3 id="class-based-chain"><a href="#class-based-chain" class="headerlink" title="class-based chain"></a>class-based chain</h3><p>會透過事先編譯來使用類別(class)來定義物件是什麼以及物件之間的關係是什麼，其中物件之間的關係無非就是繼承關係，來讓物件們擁有著相同的屬性和方法，它們具體實現的方法就是提供一些關鍵字來讓開發者方便定義哪些類別是屬於繼承關係，接著在編譯時期讓系統根據這關鍵字去決定每一個類別A是繼承繼承哪些一類別B，而這些類別B又是繼承哪些額外類別C，後面類別以此類推，在這裡系統為了更好去定義這些類別之間的繼承關係，而使用近似於Linked List結構來定義這些類別，而這個結構被稱之為類別鏈(class chain)。</p>
<p>在上述的描述中，我們可以得知類別A繼承類別B，而類別B又繼承類別C，那麼類別鏈就能以C-&gt;B-&gt;A來表達這樣子的關係，而每當要建立實體時，便會依據這條類別鏈來決定這實體所擁有的屬性和方法是為何，或者進一步決定哪些屬性和方法是由哪些類別來決定，同時也透透過類別鏈來進一步管理每一個類別。整體而言，類別鏈在編譯時期就決定並且定義了每一個類別之間的關係是什麼。</p>
<h3 id="prototype-chain"><a href="#prototype-chain" class="headerlink" title="prototype chain"></a>prototype chain</h3><p>而在JS的prototype-based的物件導向風格，一切都只能從執行中來決定每一種物件概念的prototype(相當於class-based的class)以及定義每一個prototype之間的關係，定義每一個prototype之間的關係會模仿著class-based的類別鏈概念而構建出一種可以在執行中來決定關係，也就是原型鏈(prototype chain)，透過賦予每個實體物件一些屬性以及方法來將實體物件綁定於代表物件概念A的prototype A來描述這些實體物件是屬於物件概念A的產物，而prototype A本身又是實體物件，所以可以進一步找到prototype A 是屬於哪個物件概念，後面prototype可以依此類推，那麼每當建立實體或者存取實體便會依據著這原型鏈來從中定義這實體物件究竟繼承了什麼以及哪些屬性和方法是被繼承的。</p>
<p>題外話：若持續對著該Object探尋著它的prototype則會找到null。</p>
<h3 id="prototype-實現方式"><a href="#prototype-實現方式" class="headerlink" title="prototype 實現方式"></a>prototype 實現方式</h3><p>從前面來描述來看，原型鏈(prototype chain)是定義藉由層狀結構來定義每一個物件所屬的prototype跟其他prototype存在著什麼樣的繼承關係，在JS世界中，原型鏈(prototype chain)最頂端的prototype會是JavaScript Object本身，而所有的物件都皆從Object來進行著繼承或者串連成原型鏈。JS具體構成繼承或者原型鏈的方式會是使用著代表物件概念的prototype名稱和每個函式所擁有的prototype屬性來設定原型鏈，但這只是設定原型鏈，物件屬性還未真的繼承，必須再讓繼承的物件透過call和base方法去讓自己屬性去呼叫被繼承方的constructor來設定繼承的物件的屬性和方法為何，才能算真正的繼承。</p>
<p>所以若要讓屬於prototype A的實體物件A去繼承實體物件B所屬的prototype B之屬性和方法，整體來說有兩個首要任務：</p>
<ol>
<li>將prototype B 設定在prototype A本身對應的constructor的prototype屬性，從而構成Object-&gt;B-&gt;A這原型鏈</li>
<li>在prototype A本身對應的constructor中設定方法來呼叫prototype B對應的constructor，並把想傳入的參數以及prototype A實體物件傳入進去，讓prototype B的constructor去將參數值設定只有它擁有的屬性和方法並增加至prototype A實體物件，使得prototype A實體物件擁有prototype B的屬性和方法。</li>
</ol>
<p>舉一個例子： 在這裡假設有二個用來定義prototype內容的函式(建構函式)，這兩個prototype的名稱分別為prototype1和prototype2，而建構函式的參數分別為something1和something2，這些是用來設定建立對應實體時所要有的實際屬性和實際方法，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function prototype1(something1) &#123;</span><br><span class="line">  // define something1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype2(something2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當要定義名為prototype2的prototype去繼承prototype1的屬性和方法時，會透過函式特有的prototype屬性來實現繼承，這時就定義了Object-&gt;prototype1-&gt;prototype2這原型鏈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function prototype1(something1) &#123;</span><br><span class="line">  // define something1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype2(something2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prototype2.prototype = prototype</span><br></pre></td></tr></table></figure>
<p>緊接著就是為prototype2的實體物件去(繼承)增加只有prototype1會有的屬性和方法並依據prototype2的constructor給定的參數來賦予，在這裡會在prototype2使用call來實現，當要建立prototype2的實體物件時，prototype2會呼叫prototype1的建構式，並且將prototype2對應的實體物件和參數傳入至prototype1的建構函式，讓它去為prototype2對應的實體物件增加屬性以及根據參數來設定屬性值，當執行完call的實體物件就會擁有著prototype1會有的屬性和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function prototype1(something1) &#123;</span><br><span class="line">  // define something1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype2(something2) &#123;</span><br><span class="line">  prototype1.call(this, something3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prototype2.prototype = prototype</span><br></pre></td></tr></table></figure>

<h3 id="prototype-子類"><a href="#prototype-子類" class="headerlink" title="prototype 子類"></a>prototype 子類</h3><p>在ES2015之後，JS就提供一系列class-based會用到的關鍵字和語法來封裝prototype based的概念，這些class-based關鍵字和語法在JS上就相當於語法糖的存在，在這裡若用上這些語法糖時，會用類別(class)稱呼prototype，而子類別(class)就是指繼承於其他prototype的prototype，拿上述的語法來當例子，要用class-based的語法定義兩個prototype&#x2F;類別會是如下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class prototype1 &#123;</span><br><span class="line">  constructor(something1) &#123;</span><br><span class="line">    // defefine something1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class prototype2 &#123;</span><br><span class="line">  constructor(something1) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">以上相等於下者</span><br><span class="line">function prototype1(something1) &#123;</span><br><span class="line">  // define something1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype2(something2) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>
<p>其中每一個class下會有constructor這函式，這是對應類別的建構函式，當使用new 關鍵字來配合著 prototype 名稱就會呼叫著對應constructor來建立物件，而建立過程會如同建立prototype對應的實體物件一樣。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let object1 = new prototype1()</span><br><span class="line">// call constructor of class prototype1</span><br></pre></td></tr></table></figure>

<p>接著若要透過class-based語法來進一步實現繼承功能，會使用到extends和super這兩個關鍵字，其中extends是用來指示目前類別&#x2F;prototype是繼承哪一個類別&#x2F;prototype，而super則是代表著被繼承的prototype物件本身，在這裡一樣會定義兩個prototype，分別名為prototype1和prototype2，不同的事情就是透過extends來讓prototype2去繼承prototype1所擁有的屬性和方法，在這裡，prototype1會是prototype2的父類別，而prototype2就是prototype1的子類別，最後再讓prototype2的實體物件透過super來呼叫prototype1的constructor來讓該實體物件正式獲取prototype1所擁有的屬性和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class prototype1 &#123;</span><br><span class="line">  constructor(something1) &#123;</span><br><span class="line">    // defefine something1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class prototype2 &#123;</span><br><span class="line">  constructor(something1) &#123;</span><br><span class="line">    super(something3)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">以上相等於下者</span><br><span class="line">function prototype1(something1) &#123;</span><br><span class="line">  // define something1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype2(something2) &#123;</span><br><span class="line">  prototype1.call(this, something3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prototype2.prototype = prototype</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>

<h3 id="prototype屬性：prototype-vs-class"><a href="#prototype屬性：prototype-vs-class" class="headerlink" title="prototype屬性：prototype vs. class"></a>prototype屬性：prototype vs. class</h3><p>prototype 和 ES2015所提供的語法糖在prototype相關屬性的設定大致上都會是一致，但除了屬性和方法在實際原型上的儲存會是不一樣以外，當使用prototype原生語法去定義每一個prototype會有的屬性和方法時，其constructor.prototype、object.__proto__會是prototype名稱和其擁有的屬性和方法，而當使用class語法糖去定義時，其constructor.prototype、object.__proto__只會是prototype名稱，不會儲存它所擁有的屬性和方法。</p>
<h2 id="prototype-相關術語"><a href="#prototype-相關術語" class="headerlink" title="prototype 相關術語"></a>prototype 相關術語</h2><ol>
<li>prototype：本身是用以實現某些物件概念的第一個實體物件，本身會是定義這個物件概念擁有的屬性和方法，實際上，該物件是第一個透過能夠建立某種物件概念的Constructor之實體物件，但本質上並不能完全是一般實體物件，此外，它代表著每一個物件所屬於的物件概念是為何。</li>
<li>Constructor.prototype: 每一個構造函式(Constructor)能夠具有的屬性之一，會指向該構造函式自己本身所具有的原型物件(prototype)，然而在語法上是可以允許一般函式是擁有prototype屬性</li>
</ol>
<ul>
<li><p>若是以一般函式(未以new來構成構造函數)的話，由於會指向構建function的函式所具有的原型物件，而那個原型物件正好是JavaScript Object本身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function example(parameter1) &#123;</span><br><span class="line"></span><br><span class="line">	this.parameter = parameter1</span><br><span class="line">&#125;</span><br><span class="line">console.log(example.prototype instanceof Object)</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637937478/blog/prototype/normalFunctionExample_xl5yre.png"></p>
</li>
<li><p>若是以構造函數Manager的話，會是對應該構造函數Manager本身的原型物件，在這裡由於是設定Employee的第一個實體物件來代表，所以它在判別是否為Employee的實體物件的情況下會是true，且這也代表著Manager是基於Employee這物件概念往外延伸的另一個物件概念。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Employee() &#123;</span><br><span class="line">	this.name = &quot;&quot;;</span><br><span class="line">	this.dept = &quot;general&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Manager() &#123;</span><br><span class="line">	Employee.call()</span><br><span class="line">	this.reports = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Manager.prototype = new Employee;</span><br><span class="line"></span><br><span class="line">console.log(Manager.prototype instanceof Employee)</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637937478/blog/prototype/constructorExample_ha30k1.png"></p>
<ol start="3">
<li>Instance.__proto__: 是任何物件的屬性之一，指向物件所屬的構造函數所擁有的原型物件(prototype)</li>
</ol>
<ul>
<li>若將Instance設定為構造函式 Manager時，由於構造函式本身是物件，所以系統會根據構造 “構造函式Manager” 的構造函式來找，但該構造函式Manager本身就是函式，系統會最終找上構造 “函式” 的構造函式，而它所擁有的原型正是JavaScript Object。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Employee() &#123;</span><br><span class="line">	this.name = &quot;&quot;;</span><br><span class="line">	this.dept = &quot;general&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Manager() &#123;</span><br><span class="line">	Employee.call()</span><br><span class="line">	this.reports = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Manager.prototype = new Employee;</span><br><span class="line"></span><br><span class="line">console.log(Manager.__proto__ instanceof Employee)</span><br><span class="line">console.log(Manager.__proto__ instanceof Object)</span><br></pre></td></tr></table></figure>
<img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1637938539/blog/prototype/__proto___example_mw95l5.png"></li>
</ul>
<ol start="4">
<li>Object.[[prototype]]：是ECMAScript標準下的產物，等同於Object.__proto__，並指派Object.getPrototypeOf() 和 Object.setPrototypeOf()來存取每一個物件下所擁有的構造函數所擁有的原型，但由於大部分瀏覽器在推廣之前就已經先用__proto__來代替它實現：</li>
</ol>
<ul>
<li>Object.getPrototypeOf(obj) ：根據obj物件所對應的構造函式來獲取函式所擁有的原型</li>
<li>Object.setPrototypeOf(obj, prototype)：對obj物件所對應的構造函式所擁有的原型設定成指定原型prototype</li>
</ul>
<p>參考資料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34183746">js中__proto__和prototype的区别和关系？</a></li>
<li><a target="_blank" rel="noopener" href="https://javascript.plainenglish.io/proto-vs-prototype-in-js-140b9b9c8cd5">What is the difference between prototype and __proto__ in JavaScript?
</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Details_of_the_Object_Model">深入了解物件模型</a><h2 id="補充知識"><a href="#補充知識" class="headerlink" title="補充知識"></a>補充知識</h2><h3 id="polymorphism"><a href="#polymorphism" class="headerlink" title="polymorphism"></a>polymorphism</h3></li>
<li>the fact that something such as an animal or organism can exist in different forms</li>
<li>描述同種性質的東西可以以不同形式、外形、結構來呈現&#x2F;存在，比如同屬於動物的東西可以以有翅膀、有魚鰭、有爪子的形式來存在</li>
</ol>
<h3 id="object-copy"><a href="#object-copy" class="headerlink" title="object copy"></a>object copy</h3><ol>
<li>將一個物件A所擁有的內容複製到另一個物件B，在這裡由於每一個物件都具有屬性和方法，若物件A內容被複製到成為物件B的屬性和方法，那麼這兩個物件所擁有屬性名稱、對應屬性值、方法名稱、對應方法皆會一樣。<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638015712/blog/prototype/begintoCopy_wtckkf.png"></li>
<li>但若屬性值或者對應方法本身是一個參照或者一個記憶體位址的話，那麼物件A和物件B很有可能會一起共享著同一個參照或者同一個記憶體位址，只要任何一方針對該參照對應的內容做更動，另一方就即可透過同一個參照看到更動內容，而若拷貝結果是這樣，那麼該拷貝方式就即為淺度拷貝(Shadow Copy)<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638015712/blog/prototype/ShadowCopyResult_gchjms.png"></li>
<li>若物件A內容被複製成為物件B的屬性和方法時，也連同替物件A的所有參照對應的物件內容進行複製，而非單純複製參照位址：將整個內容複製給物件B，進而讓雙方不再共享同一個參照或者同一個記憶體位址，那麼任何一方做任何更動時不會影響另一方的內容，而若拷貝結果是這樣，那麼該拷貝方式就即為深度拷貝(Deep Copy)</li>
</ol>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1638015711/blog/prototype/DeepCopyResult_wgeumz.png"></p>
<p>參考資料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_copying#Shallow_copy">object copy</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/11/14/ACSemester2-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/ACSemester2-2/" class="post-title-link" itemprop="url">AC 學期2-2 回顧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-14 16:36:29" itemprop="dateCreated datePublished" datetime="2021-11-14T16:36:29+08:00">2021-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:33" itemprop="dateModified" datetime="2022-03-18T00:06:33+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OBJECTIVE"><a href="#OBJECTIVE" class="headerlink" title="OBJECTIVE"></a>OBJECTIVE</h2><p>1個月前的我雖然可以憑藉著自己以前的基礎和現在在AC所學的技術新知來在短時間內打造一個看似可以但程式碼架構很糟的產品，那時的我就想著給自己幾個限制來加強自己對於程式碼架構的實作以及對於時間管理上的優化取捨，並把這些限制和優化都放在學期2-2的作業，而我的目標就是至少要優化到其他人看到都可以很好維護的程度且一定得在繳交期限內完成優化，具體限制則在繳交期限內，以MVC的角度來優化作業以及添加少許功能這幾個限制下來完成作業。</p>
<h2 id="REFLECTIVE"><a href="#REFLECTIVE" class="headerlink" title="REFLECTIVE"></a>REFLECTIVE</h2><p>剛開始我就對目前程式碼分類在MVC架構中的每個區塊並添加了一些額外功能，但我沒想到的事情就是程式碼有很多地方是可再次切割成較簡單且可重複的程式碼，我並沒在第一時間先做規劃，而是直接先切割然後再分類，這樣的過程難免都會因為考慮的因素太少而得一直重新寫同樣功能的程式碼，這時的我就陷入一個泥沼-越開發越多BUG，永遠開發不完的情況，更別說同期的同學也老早完成自己的作業，而我還沒開發完成，所以我只好先試著讓自己冷靜，重新思考目前要求的功能以及自己已經額外加的功能、開發架構是什麼、如何修改會比較好，哪些部分可以做取捨，隨後我就按照自己所規劃的功能來重構程式碼，然後提醒自己不要太刻意其他人的進度，自己的進度比較重要，最後我如期完成優化，現實的是我耗掉好幾天的時間，不過這段時間內我卻讓自己對於程式碼架構的開發有了更多實踐練習和感想。</p>
<h2 id="INTERPRETIVE"><a href="#INTERPRETIVE" class="headerlink" title="INTERPRETIVE"></a>INTERPRETIVE</h2><p>雖然我從這次體驗獲得程式碼架構的經驗和瞭解，但同時也發覺這樣子體驗不是如預期那般順利，而且會耗掉更多時間，甚至讓我沒太多時間去預讀後續課程的內容，我認為我應該先以MVP角度去推展優化和進度，而非只是單純分類，然後一頭栽進去做，同時我也發現我自己會因為進度落後而在優化過程中特別煎熬，但這份煎熬也提前為我做了一個預防針在未來職場上很有可能再度發生的事情，而這個預防針就是在優化過程中要想著哪些事情是該做的，哪些事情是不該做的？然後要時常為自己打氣，告訴自己做了哪些進步的事情，來讓自己持續前進。</p>
<h2 id="DECISIONAL"><a href="#DECISIONAL" class="headerlink" title="DECISIONAL"></a>DECISIONAL</h2><p>由於能給我預讀的時間變少了，我必須要MVP角度來優先推展進度，等到進度到達一定程度之後，再來想著下一個優化練習是什麼，另外正式優化之前得先想著這個時間點能做的具體架構是什麼以及每個步驟會耗掉多少時間來評估是否做優化或者做個取捨。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/11/14/eventloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/eventloop/" class="post-title-link" itemprop="url">Event loop 與 在JavaScript中的它</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-14 15:29:12" itemprop="dateCreated datePublished" datetime="2021-11-14T15:29:12+08:00">2021-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JavaScript-背景"><a href="#JavaScript-背景" class="headerlink" title="JavaScript 背景"></a>JavaScript 背景</h2><p>由網景和微軟掀起瀏覽器大戰中，瀏覽器的網頁在早期只能透過HTML檔案內容將一些文字和內容顯示在瀏覽器上，而這樣的內容就只是在電腦上顯示一張大海報，網景為了近一步打敗微軟而開發出能與網頁互動的程式語言-JavaScript，讓瀏覽器去執行網頁上的JavaScript來讓使用者的互動藉由該語言來實現特定效果，但後來微軟憑藉著作將瀏覽器綁定自家的作業系統來壟斷整個瀏覽器市場，最後打贏了網景，但網景所衍生出的JavaScript並未就此消失，而是進一步以Open Source的形式存活著並且成長為一種很成熟的語言。</p>
<h2 id="JavaScript-的執行緒"><a href="#JavaScript-的執行緒" class="headerlink" title="JavaScript 的執行緒"></a>JavaScript 的執行緒</h2><p>JavaScript的出生是因應想要讓使用者對網頁內容進行某些互動來執行某些任務，甚至可以透過改變DOM來進一步改變網頁，其中透過DOM來改變網頁是它的最大特點，但DOM的節點本身在多個執行緒下的執行環境是一個很容易被改變且會發生預期外的結果或者使網頁無法正常，比如說有多個執行緒，每一個執行緒都想對同一個DOM節點做寫入、刪除、讀取的動作，若讓負責刪除的執行緒先執行，那麼剩餘做讀取、寫入的執行緒會因為找不到該節點而出錯。</p>
<p>為了避免這樣子的問題發生，JavaScript 本身就被設定成只會有一個執行緒來執行任務，而在瀏覽器執行它的時候，其負責解析語言的元件只會建立執行一個主執行緒來負責解析並執行JavaScript本身，並從這個主執行緒來生成單一的執行緒來給予CPU執行，同一個時間點只會有一個任務被執行。</p>
<p>當然這只是建立在JavaScript本身的限制，實際上來說執行環境(如瀏覽器、Node.js)會因應HTML5所提出的Web Worker標準而開放額外的API來讓JavaScript去調用並在執行環境上建立除了主執行緒以外的執行緒，而這些執行緒會受到主執行緒來控制，並且不能夠操作DOM節點，這樣子的提供不僅增加效能，也保證DOM節點會是單個執行緒(也就是主執行緒)來執行。</p>
<ul>
<li><p>JavaScript之所以為直譯語言，是原本就為了盡可能讓開發者快速進行網頁上開發好拓展網景瀏覽器的市場，同時也盡可能減少編譯時所帶來的額外成本，但缺點就是語言會是弱型別且每一次執行都要重新解析並執行。</p>
</li>
<li><p>Main Thread 是瀏覽器底下的Renderer Process底下的Thread，而Renderer Process主要是渲染引擎的執行實體，負責解析同一個網頁下的HTML、CSS並計算每個網頁元素的位置以及實際上的繪製、執行JavaScript程式碼，而Main Thread是主要是負責包攬這些工程的thread，主要是解析同一個網頁下的HTML、CSS並計算每個網頁元素的位置並生成對應的繪製指令給其他同為Process下的Thread進行繪製、執行JavaScript程式碼，而Main Thread的數量本身會是單個執行緒。</p>
</li>
<li><p>Web Worker 標準是為了盡可能減緩單執行緒所引發的blocking問題 - 前面的任務會因為等待或者執行關係而拖延到後面的任務，進而讓後面任務無法正常執行，解法就是允許JavaScript去額外產生Worker Thread去分擔這些任務，好讓Main Thread順利執行，同時間只允許Main Thread操作DOM節點，其他Worker Thread不得執行，這是為了滿足JavaScript的設計初衷 - 同時間不得有多個執行緒去對DOM節點做處理，甚至是同一個節點的處理。</p>
</li>
</ul>
<h2 id="電腦處理任務的方式"><a href="#電腦處理任務的方式" class="headerlink" title="電腦處理任務的方式"></a>電腦處理任務的方式</h2><p>一般來說，一個程式碼若要確實被執行，過去一定得將程式碼封裝成Process這基本形式來讓Scheduler去分配實體CPU執行，另外在這裏會用任務來稱呼特定功能的程式碼，並非真的是指能被當排程的基本單位，當封裝成Process形式之後，就會被放入一個準備佇列(Ready Queue)等待Scheduler排到他，最前面的任務會被Scheduler按照任務性質來將任務分配至特定的佇列(Queue)，每一個佇列都對應著實體CPU，等待Scheduler分配完最前面的任務後，再由次先的任務進行分配，後面以此類推，當然對應CPU的佇列也都是如此，會先從自己對應的佇列中挑第一個任務執行，然後執行完隨後挑次先，一直到佇列為空。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636632652/blog/event/eventloop/scheduling_szgjwp.png"></p>
<p>而現代作業系統不再以Process形式來當基本排程形式，而是以執行緒(Thread)為基本排程形式來給Scheduler，具體實現方式是將一個程序X上的功能切分成分成好幾份子功能並按照份數來建立執行緒，每個執行緒會從中拿到獨立功能來執行並且共享(可能會共享著程序X的變數、函式)著同一個程序X來代表著程序X執行某些功能，而這樣子的切分會由於同個程序X上的Thread為單位來佔用多個CPU資源執行，進而使一個程序X所發揮出來的效率會比單純以Process來排程來得好，畢竟後者最多只能拿到一個CPU資源來執行。在這裡我們皆用任務來稱呼每個要被排成的執行緒。</p>
<p>而電腦處理任務的方式，同步處理和非同步處理，理論上，同步處理下的任務們只會在同一個時間點內執行一個任務，而且每一個任務皆必須等待上一個的任務結束才能執行，而非同步處理下的任務們可以各自被執行，而且每一個任務都不用等待任何一個任務就能繼續執行。</p>
<p>然而，實際上會按照實體CPU的數量以及是否支援非同步處理，若CPU數量只有一個的話，只能夠支援同步處理，也就是一次只能執行一個任務(如下圖)。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636720649/blog/event/eventloop/singleCPU_xvyctj.png"></p>
<p>但若CPU數量多於一個的話，就能支援非同步處理，在這情況下就同時執行執行多個任務，但不能夠說完全不用等待，因為實體CPU也就N個，若要排進CPU的任務大於N個時，勢必會有任務需要等待前面的任務完成才能做。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636720649/blog/event/eventloop/multipleCPU_w9o1hc.png"></p>
<h2 id="JavaScript-如何處理任務"><a href="#JavaScript-如何處理任務" class="headerlink" title="JavaScript 如何處理任務"></a>JavaScript 如何處理任務</h2><p>首先電腦本身只能看懂由0和1所構成的機械碼，它不會明白JavaScript的語法在講些什麼，而當時設計者為了讓開發者能夠快速開發來強占瀏覽器的市場而捨棄較嚴謹的編譯語言，改由直譯語言，其中編譯語言是一種事先將程式的語法(偏易於人類看懂的語法)轉譯成機械能看懂的形式，並直接讓執行環境去執行的，但由於可以事先轉譯，基本會要求開發者寫出的程式碼語法要先滿足一定程度的規則才能成功轉譯成機械能看懂的形式，比如要求開發者告知每個資料和變數的資料型別是什麼。而直譯語言則是不用事先編譯成機械碼，而是透過一個程式X來一行一行邊讀取程式碼邊轉譯成機械碼來執行，而這個程式X會是解釋器，通常執行成本會比編譯語言來得高，但透過不煩瑣的規則來讓開發者能夠快速開發。</p>
<p>實際上來說，JavaScript本身就實現著同步處理，瀏覽器會提供一個Main Thread來負責解析並以JavaScript解釋器(常以一個專門解析的JavaScript引擎來代表)來建立一個執行緒給予CPU的Scheduler來分配實際CPU去執行，進而滿足JavaScript的直譯和單一執行緒這兩個先決條件，而該Main Thread會是源自於主要負責同一個網頁的渲染和事件處理的Renderer Process，如將網頁解析成Render Tree、處理Layout、執行Paint等等</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641137948/blog/event/eventloop/simpleBrowserSystem_l1y2px.png"></p>
<p>在這裏由於瀏覽器的Main Thread只會生成一個執行緒去執行，而JavaScript本身是依照一行一行來讀取並轉譯執行，也就是說同一個時間內只會有一個任務(夾帶著轉譯後的JavaScript)能夠被Main Thread執行，而後面的任務(夾帶著轉譯後的另一個JavaScript)則必須等前面的任務被CPU執行完成才能被執行，從這樣子來看，就是個典型的同步處理，而在這裡由Main Thread所生成出來的單個執行緒儼然對他們而言就是個實體CPU。</p>
<h3 id="同步處理的常見問題-Blocking"><a href="#同步處理的常見問題-Blocking" class="headerlink" title="同步處理的常見問題 - Blocking"></a>同步處理的常見問題 - Blocking</h3><p>根據同步處理的特性：</p>
<blockquote>
<p>同步處理下的任務們只會在同一個時間點內執行一個任務，而且每一個任務皆必須等待上一個的任務結束才能執行</p>
</blockquote>
<p>當目前執行的任務一直使用著CPU資源或者佔用著CPU並向外部請求時，會阻塞(block)後續的任務(程式碼)沒辦法及時執行，而這個現象叫做阻塞(Blocking)，以下用程式碼來示範，下面分別會從foo.com、bar.com、qux.com取得資料，並列印出來，過程中會因為getSync佔用著CPU資源去索求外部資源，並等待外部發送回應給getSync，其結果就是整個程式的執行會因為前面三段getSync而產生阻塞現象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let foo = $.getSync(&#x27;//foo.com&#x27;)</span><br><span class="line">let bar = $.getSync(&#x27;//bar.com&#x27;)</span><br><span class="line">let qux = $.getSync(&#x27;//qux.com&#x27;)</span><br><span class="line"></span><br><span class="line">console.log(foo)</span><br><span class="line">console.log(bar)</span><br><span class="line">console.log(qux)</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636733654/blog/event/eventloop/BlockingExample_z4gh1m.gif"></p>
<h2 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h2><p>當執行JavaScript檔案時，系統會根據Scope規則來建立較為抽象的執行環境(Execution Context)來概括並辨別該環境能有的變數、函式、狀態等資訊，而整份檔案會是個一個全域執行環境(Global Execution Context)，若遇到函式或者由括號建立的執行環境時，會是在全域執行環境下建立一個區域性執行環境(Local Execution Context)或者函式執行環境(Function Execution Context)，所有在這個區域性執行環境的變數和函式都只會在這個環境下存活並能夠被辨別以及執行。</p>
<p>在這裡為了要清楚辨別全域執行環境和哪些區域執行環境先被執行，每當一執行JavaScript檔案，就先建立全域執行環境並推入(Push)Stack中，接著當這環境下有段會呼叫函式X時，會建立以函式X為主的區域性執行環境X來記錄，並且推入至Stack的最上面，而當在目前區域環境X中遇到了return語法 或者 沒東西可讓環境X繼續執行(存在)，就表示該環境X要回傳並釋放記憶體，此時就會從Stack移出(Pop)最上面的環境X(也就是目前執行環境X)。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641141910/blog/event/eventloop/CallStackDiagram_znytvk.png"></p>
<p>而當該全域環境執行完畢時，便也會從Stack移出它。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641142253/blog/event/eventloop/popGlobalExecutionContext_vzsf1o.png"></p>
<ul>
<li>在這裡，若要先執行JavaScript程式碼的話，都會先被系統放入JavaScript引擎所給予的call stack環境來給予引擎解析JS、執行、呼叫額外API。</li>
</ul>
<h3 id="Call-Stack-例子"><a href="#Call-Stack-例子" class="headerlink" title="Call Stack 例子"></a>Call Stack 例子</h3><p>在這裏我們建立三個函式分別為funct1()、funct2()、funct3()，然後在定義他們之後呼叫他們去執行來觀察他們與Call Stack之間發生什麼事情，範例程式碼如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function funct1() &#123;</span><br><span class="line">    console.log(&#x27;funct1&#x27;)</span><br><span class="line">    funct2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function funct2() &#123;</span><br><span class="line">    console.log(&#x27;funct2&#x27;)</span><br><span class="line">    funct3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function funct3() &#123;</span><br><span class="line">    console.log(&#x27;funct3&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funct1()</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br></pre></td></tr></table></figure>

<p>在這裏是採用Loupe平台來觀測程式碼和Call Stack之間的互動，在這個平台中並不會把main function特意顯示，程式碼結果如下，首先系統會先呼叫funct1()，執行funct1後便將funct1()推入在Call Stack中去紀錄，然後去印funct1這字串，接著funct1()又呼叫funct2()，這時會將funct2()推入在Call Stack中紀錄，funct2()會在funct1()之上，然後去印funct2這字串，最後再由funct2()呼叫funct3()，這時會將funct3()推入在Call Stack中紀錄，funct3()會在funct2()之上，然後去印funct3這字串。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636728641/blog/event/eventloop/CallStackExample_kay9ld.gif"></p>
<p>而funct3執行完畢後，也沒呼叫什麼以及執行什麼，此時Call Stack會移出目前最上面的函式-funct3()，而系統會在移出後自動抓最上面的函式-funct2()來返回funct2()呼叫funct3()的地方，接著funct2()也沒呼叫什麼以及執行什麼，此時Call Stack會移出目前最上面的函式-funct2()，而系統會在移出後自動抓最上面的函式funct1()來返回funct1()呼叫funct2()的地方，接著funct1()也沒呼叫什麼以及執行什麼，就便讓Call Stack移除目前最上面的函式-funct1()，最後回到main function呼叫funct1()的地方，隨後在印個end這字串</p>
<h3 id="Call-Stack-極端例子-不斷地呼叫"><a href="#Call-Stack-極端例子-不斷地呼叫" class="headerlink" title="Call Stack 極端例子 - 不斷地呼叫"></a>Call Stack 極端例子 - 不斷地呼叫</h3><p>當函式一直不斷地呼叫時，會不斷往Call Stack推入更多函式，這會使得Call Stack本身被佔用，以下面的程式碼做為例子，程式碼會先定義funct1()，其內部會是呼叫funct1()，接著在呼叫funct1()，最後結果會是讓funct1()不斷被自己呼叫，直到被開發者中斷、系統自己中斷才停止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function funct1() &#123;</span><br><span class="line">    funct1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funct1()</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636732264/blog/event/eventloop/infExample_boi9hh.gif"></p>
<h2 id="什麼是事件"><a href="#什麼是事件" class="headerlink" title="什麼是事件"></a>什麼是事件</h2><p>當對特殊元件做出某些行為時，這些元件會發射對應行為的信號，然後再藉由攔截信號來執行的特定任務X，在這裏信號正是被稱作為 “事件(event)”，而特定任務X則是這個事件發生時所要做的事情，事件和特定任務X之間的互動可以實現使用者對於軟體上的元件互動，比如點擊某個按鈕就跑出一系列的清單、滑動卷軸能夠往下看後續內容。而為了實現整體事件系統的處理，勢必會得要有一個機制在軟體Y上來監聽某種信號&#x2F;事件以及產生對應的特定任務X。</p>
<h3 id="如何實現事件？"><a href="#如何實現事件？" class="headerlink" title="如何實現事件？"></a>如何實現事件？</h3><p>在這裏的軟體Y和被監聽的元件之間會有二種方式來實現：</p>
<ol>
<li>pull (polling)：由軟體Y在固定時間內產生任務去詢問對應元件是否要產生事件&#x2F;信號，若詢問結果是要產生，便直接執行對應的特定任務X，但詢問一直失敗很容易造成不必要的效能損益，尤其是關心的元件可能不止於1種，可能總加起來的數量會是N個，那麼負責詢問的任務數量在固定時間內也是N個。</li>
<li>push：由發送信號的元件來通知軟體Y處理，在事件發生前，軟體Y可以做自己的事情，在這裡軟體Y可以事先告知元件當事件發生時該如何處理，或者一律選擇由軟體Y來處理事件。</li>
</ol>
<p>一般來說，軟體Y為了效率而可能會採用push這個異步處理來實現事件，甚至在當元件上的特定事件發生時，就會產生特定的執行緒來執行每個事件的特定任務，雖然效率上，可以藉由這樣而不把事件處理全給軟體Y的主要執行緒上，但實際上來說，若這些執行緒彼此間共用相同資源時，會產生一種名為Critical-Section Problem 或者 Race Condition，且由於事件對應的特定任務會因為事件的不可預知性而使這個問題更難解決，另外事件就算給予軟體Y主執行緒來執行，還是因爲共享資料的關係而不能保證這些執行緒不會有這些問題。</p>
<ul>
<li><p>push：原意為在不通知對方的情況下，先透過網路發送資訊至對方，在這裡是指特殊元件發送通知資訊至軟體或者某個特殊程式模組</p>
<blockquote>
<p>to send information over the internet without receiving a request for it first</p>
</blockquote>
</li>
<li><p>pull：透過主動的詢問或者搜尋來從網路上獲取資訊，在這裡是指軟體或者某個程式模組去從發送信號的元件詢問他是否發生事件或者發射信號</p>
<blockquote>
<p>to get information from the internet, after asking or searching for it</p>
</blockquote>
</li>
</ul>
<h2 id="事件會發生什麼問題"><a href="#事件會發生什麼問題" class="headerlink" title="事件會發生什麼問題"></a>事件會發生什麼問題</h2><p>不論是否為Critical-Section Problem 或者 Race Condition，執行緒本身是共享著同一份程序(Process)的資源並從中分出一個子功能來執行，所以共享資源是難以避免，而每一個要使用共用資源的執行緒肯定存在著存取共用資源的程式碼區塊，而這些區塊被稱之為Critical-Section，當有多個執行緒在這個區塊是存取(Access)同一個資源時，而存取可以是修改、刪除、讀取、寫入等一系列操作，這些執行緒很有可能因為彼此都想要存取同一個資源而使每個執行緒的最後執行結果變得不如預期，有些可能因為讀取到其他執行緒修改的值、也有些則是因為讀取到的資源被刪除了，而這種彼此競相存取&#x2F;修改同一個資源的行為就叫做競爭情況(Race Condition)，此時發生該情況的Critical Section就稱之為Critical-Section Problem。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636791025/blog/event/eventloop/raceConditionDiag_vp78kk.png"></p>
<ul>
<li>Critical section：程式碼中負責存取與其他任務共享的資源之程式碼區塊，而section正是指區塊</li>
<li>Race condition：源自於電路上兩個信號源彼此競爭誰出佔用唯一的輸出管道來進行輸出，在電腦科學裡，是指著多個執行緒彼此競爭誰先存取到同個共享資源。</li>
</ul>
<h3 id="問題例子"><a href="#問題例子" class="headerlink" title="問題例子"></a>問題例子</h3><p>假設說有一個任務1想要存取某個資源Y下的X值來處理自己的任務內容，而資源Y本身對於系統而言是可以共享存取的，所以任務1的Critical Section會是存取資源Y的X值之程式碼(如下)，首先會透過id來取得資源Y這個物件，然後透過其資源Y的getXValue來取得X值，預期這個任務1會拿到X&#x3D;1來做處理，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Critical Section</span><br><span class="line">resource = getResourceById(id)</span><br><span class="line">result = resource.getXValue()</span><br><span class="line">// Critical Section</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636642604/blog/event/eventloop/criticalSectionExample1_zflvd8.png"></p>
<p>然而突如其來的特定任務X想要修改該資源Y下的X值，使值從1轉換為2，任務2的Critical Section會是如下，會透過id來取得資源Y這個物件，然後透過其資源Y的modifyXValue(2)來將X值修改成2，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Critical Section</span><br><span class="line">resource = getResourceById(id)</span><br><span class="line">result = resource.modifyXValue(2)</span><br><span class="line">// Critical Section</span><br></pre></td></tr></table></figure>

<p>若這兩個任務同時都各由獨立的CPU資源來執行，執行先後順序會無法從中定義，但若是先從特定任務X執行或者在執行任務1的存取X值的同時下任務X就已經修改的話，任務1只會讀取X&#x3D;2，而非是讓任務1讀取X&#x3D;1，這樣子的存取很有可能會讓任務1的執行結果是不如預期，甚至無法正常執行<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636642604/blog/event/eventloop/criticalSectionExample2_jnecq7.png"></p>
<h2 id="系統如何解決問題"><a href="#系統如何解決問題" class="headerlink" title="系統如何解決問題"></a>系統如何解決問題</h2><p>面對這樣子的Critical-Section Problem，系統主要有兩種方式，第一種使用鎖(lock)機制，讓先存取資源的人能夠鎖住資源，不讓其他人在同時間使用資源，第二種使用事件迴圈(event loop)，這種會強制將要存取Critical Section的任務轉換為同步處理，透過同步處理的特性-同一時間只允許一個任務執行，不過這兩種只是阻止同時間的修改，若先修改同一份資源的任務先執行的話，還是會讓後面執行的任務會出現不如預期的問題，拿先前的問題例子中的任務1和任務X，任務1只要先存取資源Y，就能皆能透過這上述任意方式來保證任務1再存取的同時間不會有任務X來存取或者修改，但是如果任務X先於任務1的話，那麼任務1到最後還是會取到X&#x3D;2，為此，就有人提出另一種event loop來解決。</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>由於資源本身的存取是透過Critical Section來達成，因此可以被視作為資源的代言人，而 lock 這一個機制會允許任何一個先存取到Critical Section的程式替這個Critical Section或者對應的資源上鎖，使得後面想要存取同一個資源的任務都會被鎖給擋住(Blocked)，而當上鎖該資源並存取資源的任務只要存取完畢，便會把鎖解開讓後面的任務去存取，當然先搶到的任務可以擁有先鎖住資源的權利。除了上述之外，鎖本身會阻塞(Block)想要存取同一個資源的任務，因此若想要存取同一個資源的任務一多的時候，效能很有可能會因為阻塞而衰減。</p>
<p>以問題例子上的任務1和任務X為例，具體實現會是宣告兩個任務都能辨識的lock變數以及基於lock的while來實現lock，將這些分別放置在兩個任務對於同份資源的Critical Section中(內容如下)，而一開始的lock值會是false，當其中一方改變了lock值，另一方能夠看到變動。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 任務1的Critical Section</span><br><span class="line">while (lock) &#123;&#125;</span><br><span class="line">  lock = true</span><br><span class="line">  resource = getResourceById(id)</span><br><span class="line">  result = resource.getXValue()</span><br><span class="line">  lock = false</span><br><span class="line"></span><br><span class="line">// 任務X的Critical Section</span><br><span class="line">while (lock) &#123;&#125;</span><br><span class="line">  lock = true</span><br><span class="line">  resource = getResourceById(id)</span><br><span class="line">  result = resource.modifyXValue(2)</span><br><span class="line">  lock = false</span><br></pre></td></tr></table></figure>

<p>所以在這裏只要讓任務1先去執行下面程式碼就能透過lock設定為true來鎖住資源Y，而當任務X要去執行的時候會因為lock為true而一直跑無限迴圈，直到任務1存取完資源Y時，<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636795235/blog/event/eventloop/lockExample_y0f60k.png"></p>
<p>，直到任務1存取完資源時，就便將lock設定為false，使任務X能夠從無限迴圈跳開去修改資源Y的X值為2</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636795564/blog/event/eventloop/lockExample2_nt7vjj.png"></p>
<h3 id="simple-event-loop"><a href="#simple-event-loop" class="headerlink" title="simple event loop"></a>simple event loop</h3><p>event loop 是指著負責分發適當任務執行的流程迴圈，也就是會重複做相同分發任務執行，只是任務會隨著分發而有所不同，本身會運用一個佇列(Queue)、從佇列中挑出一個最前面的元素、挑出的元素只給主執行緒來執行這三個因素來將原本設定為異步處理的任務轉換成以同步處理的任務，從而解決Critical Section Problem 以及 鎖帶來的阻塞問題，具體方式如下，每一次由事件觸發而衍生出事件處理任務皆放入任務佇列(Task Queue)，而負責轉交給Scheduler或者執行任務的執行緒只會有一個，當中會從佇列的最前面任務挑出來放入至主執行緒去做執行，接著分派給Scheduler去執行，當執行完之後便會挑選下一個在佇列的任務，直到清空。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636798774/blog/event/eventloop/simpleEventLoop_jdc87i.png"></p>
<p>所有放在佇列中的任務全都會如同步處理那樣：</p>
<blockquote>
<p>同步處理下的任務們只會在同一個時間點內執行一個任務，而且每一個任務皆必須等待上一個的任務結束才能執行</p>
</blockquote>
<p>而這樣子的處理也避免使用鎖以及鎖帶來的阻塞現象，當然也得要考量每一個被執行的任務是否本身就是個阻塞其他任務的任務。這方法本身效能會因受限於只有單執行緒能執行以及像鎖那樣無法完全避免Critical Section Problem帶來的不可預期之執行結果。</p>
<ul>
<li>這裡提到的主執行緒或者main thread並不是指Renderer Process下的Main Thread</li>
</ul>
<h3 id="complex-event-loop"><a href="#complex-event-loop" class="headerlink" title="complex event loop"></a>complex event loop</h3><p>為了進一步提升效能和緩解Critical Section Problem帶來的不可預期之執行結果，就額外添加多執行緒以及額外Queue來延遲真正造成不可預期的任務，在這裏由一個主要執行緒根據哪些任務是真正容易對共用資源造成不可預期的任務來分發至不同地方來執行：擁有多個執行緒的空間(Thread Pool)、暫緩執行用的空間，通常會是對某些內容進行寫入、刪除、變更的功能會被歸納成容易對共用資源造成不可預期的任務，讀取、修改某副本內容、沒涉及共用資源的功能則是歸納成較安全的任務(Thread-safe)。</p>
<p>首先一開始還是會由每一次由事件觸發而衍生出事件處理任務都放入任務佇列，由主要執行緒(Main Thread)從佇列中挑選第一個任務並判別其性質進行分發，若是不會對共用資源造成任何修改的任務，則會被放入Thread Pool，在這裏會分配多個執行緒去執行任務，而若主要執行緒判別任務為會對共用資源造成任何修改的任務，則放入另一個Queue等待適當時機回到Main Thread執行</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636803337/blog/event/eventloop/complexEventLoop_ocm5jl.png"></p>
<p>Thread Pool本身是由固定數量的執行緒組成，平時會保持著可幫助任務執行的狀態，但由於數量有限，所以會用佇列來存放被放進Thread Pool的任務，等著哪些執行緒是可幫忙執行的狀態再來從佇列中挑選前面的任務來執行，當沒有執行緒可用時，便會停止挑選直到有可用的執行緒。所有被執行緒執行完的任務會回傳至主執行緒做最後的處理以及回傳結果。<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636804100/blog/event/eventloop/threadPoolOnEventLoop_rmfugm.png"></p>
<p>而被真正容易對共用資源造成不可預期的任務會被放進一個Queue，當然這個佇列也是等待著執行緒去執行，只是負責執行的執行緒和執行方式都跟上述有所不同，由於這些任務很容易對共用資源造成不必要且不可預期的結果，所以會試著等其他要使用共用資源的任務執行完再來從這個佇列挑出來至主執行緒來執行。<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636804544/blog/event/eventloop/queueOnEventLoop_ilrszi.png"></p>
<p>整體來說，這個event loop架構會盡可能透過開放多執行緒讓任務們的執行效率提高以及藉由佇列來分離出一些很容易對共用資源造成不必要且不可預期的任務並放進另一個佇列等待時機在主執行緒執行。</p>
<ul>
<li>這裡提到的主執行緒或者main thread並不是指Renderer Process下的Main Thread</li>
</ul>
<h2 id="JavaScript-的事件"><a href="#JavaScript-的事件" class="headerlink" title="JavaScript 的事件"></a>JavaScript 的事件</h2><p>在這裏的JavaScript由於本身時常應用於瀏覽器，所以會以瀏覽器的事件來進行說明，首先當瀏覽器將網頁上所有元件轉換成適當的實體模型以及計算每個元件的實體位置、大小等資訊時，便賦予網頁上的所有元件在執行環境(瀏覽器)上是具有事件接收和事件觸發的物件，而所有對事件&#x2F;信號的發送會由瀏覽器(瀏覽器還調用著作業系統的API來接收信號)負責轉送。 </p>
<p>也就是說當使用者對著元件X進行點擊且設定名為onElementXClicked函式來當作事件發生所要做的處理時，addEventListener本身會先建立專屬於元件X的EventListener物件，該物件會以清單的形式來紀錄元件X上所有綁定的事件種類和對應事件處理內容，而瀏覽器實際上會在利用先前提到的資訊計算、實體模型去判斷這個點擊信號是屬於哪個DOM物件，然後鎖定該DOM物件就檢測其物件是否有相關事件物件(比如EventListener物件)，若有的話，就根據事件種類來找尋對應的函式來當作事件處理，在這裏函式會是onElementXClicked，所以點擊元件後會顯示hi這字串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elementX.addEventListener(&#x27;click&#x27;, function onElementXClicked(event) &#123;</span><br><span class="line">  console.log(&#x27;hi)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Event-Flow"><a href="#Event-Flow" class="headerlink" title="Event Flow"></a>Event Flow</h3><p>然而，如果使用者對著巢狀結構下的子元件來進行互動時，比如類似於程式碼中的元素3(element3)，那麼瀏覽器該如何判定這次的互動&#x2F;事件是屬於哪個元素呢？瀏覽器大可直接根據事件是源自於哪裡來將事件歸類於element3，並且由它的事件處理來處理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;element1&gt;</span><br><span class="line">   &lt;element2&gt;</span><br><span class="line">   	&lt;element3&gt;</span><br><span class="line">		content</span><br><span class="line">	  &lt;/element3&gt;</span><br><span class="line">   &lt;/element2&gt;</span><br><span class="line">&lt;/element1&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可由於是巢狀關係(如下圖)，元素3(element3)被元素2(element2)所包含著，而元素2(element2)被元素1(element1)包含著，嚴格來說，當使用者對元素3(element3)做互動，同樣地也對著另外兩個元素進行互動，更甚至說包含這些元素的元素(比如body)也跟著互動。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630587482/blog/event/threeElements_lohr6c.png"></p>
<p>這時，瀏覽器可以有幾種選擇去決定事件是屬於哪個元件，第一種選擇是按照之前的規則，直接將事件歸類於元素3(element3)並發送信號給元素3，並對元素3的EventListener來找尋對應的事件處理，另外一種則是使用事件流(event flow)將訊號傳遞給每個包含元素3的元素，並試著對這些元素的EventListener找尋對應的事件處理，只是傳遞方向又可以細分兩種，一種是從最外圍的元素1開始往內傳遞的事件捕獲(event capture)，也就是信號會先傳遞至元素1，接著在傳遞元素2，最後傳遞元素3，另外一種則是從元素3往外傳遞信號的事件冒泡(Event bubbling)，也就是信號會先傳遞至元素3(發生事件的來源處)，接著在傳遞至元素2，最後傳遞元素1。</p>
<p>不過實際上來說，瀏覽器傳遞信號會一次分三種階段來傳遞信號，當對一個目標元件X產生互動時，第一個階段會先從包含元件X的最外面元件到內部元件來傳遞信號的捕獲階段(Capturing Phase)，第二個階段為從目標元件X的父元件傳遞信號至目標元件X的目標階段(Target Phase)，最後一個階段會先從目標元件X往外傳遞信號的冒泡階段(Bubbling Phase)，當使用者對某個元件X進行互動時，瀏覽器會先透過第一個階段來傳遞信號，接著就是第二個階段：將信號傳遞至實際發生事件&#x2F;互動的元件X，最後就是第三個階段傳遞信號。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636879992/blog/event/currentPropagationPath_rj9x5j.png"></p>
<h2 id="JavaScript-上的-Event-Loop"><a href="#JavaScript-上的-Event-Loop" class="headerlink" title="JavaScript 上的 Event Loop"></a>JavaScript 上的 Event Loop</h2><p>當瀏覽器按照event flow傳遞事件&#x2F;信號的時候，若單純由JavaScript負責接收事件&#x2F;信號與事件處理的話，會因爲在(瀏覽器)Renderer Process中的主執行緒只會產生一個執行緒執行而容易發生阻塞現象，讓後續的任務無法繼續做，因此瀏覽器或者執行環境為了補足這塊而提供Web API讓JavaScript能夠額外建立worker thread去處理接收事件&#x2F;信號與事件處理，隨後為了要讓主執行緒處理後續的處理結果，會將這些結果以及主執行緒事先給定好的處理方式封裝成任務至對應的任務佇列，主要的任務佇列有以下幾種，主要會按照使用的語法、是否較快執行、佔比是否較小、是否為渲染來分配。</p>
<ul>
<li>Mircotask Queue：如同其名，主要存放執行較快且資源佔比較小的任務，如Promise，主要會從Web API那邊接收任務</li>
<li>Render Queue：如同其名，主要存放負責畫面渲染的任務，如計算每個網頁元素的佈置方式、大小等等，主要會從Web API那邊接收任務或者由其他任務或者自身負責的渲染業務。</li>
<li>Marcotask Queue：如同其名，對比於Mircotask，主要會存放執行較慢且資源佔比較重的任務，如event、DOM，主要會從Web API那邊接收任務</li>
</ul>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641308751/blog/event/eventloop/baseBrowserModel_valbif.png"></p>
<p>除了這三個佇列以外，Call Stack會是JavaScript引擎所提供的堆疊，主要放著目前主執行緒在執行的JavaScript程式碼，當Call Stack為空時，就會透過event loop的機制-從佇列中取出任務分配至適合的地方來執行，接著睡眠等待下一個取出任務的週期發生，但在這裡會有三個佇列，考量到Marcotask和Mircotask本身會影響Render Task所處理的畫面以及他們的執行快慢，所以為了 <strong>盡可能讓Render Task能夠先以最新畫面來渲染，會先讓最快執行的任務-Mircotask優先執行，接著Render Task在隨後執行，最後執行較慢的Marcotask 就放到後面</strong> ，順序會是：</p>
<ul>
<li>先挑Mircotask Queue的最前面任務並移出至Call Stack來給JavaScript引擎執行，當Mircotask Queue清空就挑下一個Queue</li>
<li>挑Render Queue的最前面任務並移出和轉換成對應的繪製指令給同種Process下的其他負責GUI渲染的執行緒來負責實際畫面渲染，當Render Queue清空就挑下一個Queue</li>
<li>挑Marcotask Queue的最前面任務並移出至Call Stack來給JavaScript引擎執行。</li>
</ul>
<ul>
<li><p>除了Mircotask Queue、Render Queue、Marcotask Queue以外的佇列，其實還有比Mircotask更快更輕量的任務，該任務會放在名為nextTick Queue，在該佇列中的任務被稱之為tick task(tick 原文意旨時間極短的)，但在這裡為了展現主要會有的任務種類而只提出三種佇列。</p>
</li>
<li><p>關於佇列被event loop挑宣的優先權會是：nextTick Queue 為第一，Mircotask Queue為第二，Render Queue為第三，Marcotask Queue為第四。</p>
</li>
<li><p>Micro vs. Marco ：前者形容輕量且小，後者形容較重且大，形容任務的話，Microtask 是指執行較快且資源佔比較小的任務，Marcotask 是指執行較慢且資源佔比較大的任務</p>
</li>
<li><p>JavaScript 程式碼主要區分為tick task、microtask、marcotask，不會因為事先放在call stack或者先執行就改變他們所具有的任務種類，比如原本為marcotask 的console.log先放在call stack執行，而不是以callback形式來執行，該任務還是因爲本身執行較慢且相較於其他任務，資源佔比較重，所以還是仍為marcotask</p>
</li>
<li><p>Macrotask 總是在 JS 代碼執行完成並且 Microtask Queue 清空之後執行</p>
</li>
</ul>
<h3 id="Event-Loop-例子"><a href="#Event-Loop-例子" class="headerlink" title="Event Loop 例子"></a>Event Loop 例子</h3><p>假設負責讀取內容的執行緒讀取到一個夾雜JavaScript的HTML檔案，若其JavaScript程式碼先於其他HTML元素出現，這時主執行緒就會將這些JavaScript程式碼包裝成任務或者環境在call stack執行，此時負責讀取內容的執行緒仍繼續讀取JavaScript之後的HTML程式碼，當它便把這些程式碼也包裝成任務放進主執行緒內部的Render Queue，這時call stack和Queue會是如下狀況：<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641311954/blog/event/eventloop/EventLoopSimpleExampleStep1_gpndcm.png"></p>
<p>當call stack一清空時，主執行緒就會按照佇列優先權來挑一個佇列清空，這時只有Render Queue是還有任務的，所以主執行緒就會透過event來挑該佇列的第一個任務並移出轉換成對應的繪製指令給其他負責實際渲染的執行緒去做渲染，第一個被移出之後，隨後再挑第二個渲染任務，一直到佇列為空：</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641311955/blog/event/eventloop/EventLoopSimpleExampleStep2_uxukin.png"></p>
<p>接著之後，若負責讀取內容的JavaScript檔案中的程式碼包含以下程式碼，這段程式碼會間接呼叫WebAPI中的DOM來將onElementXClicked當作是特定元件X的點擊事件所要做的處理，並建立額外Thread去負責監聽該特定元件的點擊事件和儲存對應的處理-onElementXClicked</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elementX.addEventListener(&#x27;click&#x27;, function onElementXClicked() &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641312606/blog/event/eventloop/EventLoopSimpleExampleStep3_zcxjfz.png"></p>
<p>當特定元件X被點擊一次的時候，由於DOM的事件處理皆為Marcotask，所以負責監聽的Thread接收信號時就按照任務種類將對應的處理放在Marcotask Queue。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641312606/blog/event/eventloop/EventLoopSimpleExampleStep4_ogag3a.png"></p>
<p>此時由於call stack仍為空的且只有Marcotask Queue，主執行緒就透過event loop來將放在Marcotask Queue的第一個任務移出至call stack來執行。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641312606/blog/event/eventloop/EventLoopSimpleExampleStep5_c11qvu.png"></p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1641312977/blog/event/eventloop/EventLoopSimpleExampleStep6_lnsoiw.png"></p>
<h3 id="事件下的Event-Loop-例子"><a href="#事件下的Event-Loop-例子" class="headerlink" title="事件下的Event Loop 例子"></a>事件下的Event Loop 例子</h3><p>在這裏以HTML形式設定兩個按鈕元件，它們的id分別為testbtn1、testbtn2，而JavaScript則是為這兩個按鈕添加點擊事件，而對應的事件處理皆為onClick，接著我輪流點testbtn1、testbtn2，一直到點擊第五次，也就是點擊完testbtn1就停下了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// inside js </span><br><span class="line"></span><br><span class="line">$.on(&#x27;#testbtn1&#x27;, &#x27;click&#x27;, function onClick() &#123;</span><br><span class="line">    console.log(&#x27;button1 is clicked&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line">$.on(&#x27;#testbtn2&#x27;, &#x27;click&#x27;, function onClick() &#123;</span><br><span class="line">    console.log(&#x27;button2 is clicked&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// inside html </span><br><span class="line"></span><br><span class="line">&lt;button id=&quot;testbtn1&quot;&gt;button1&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;testbtn2&quot;&gt;button2&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>影片可以點擊下方來看，首先瀏覽器上的JavaScript遇到事件綁定時會呼叫瀏覽器下的Web API去替那個兩個按鈕增加點擊事件，接著當點擊testbtn1時，瀏覽器負責管理事件接收和處理的執行緒會將testbtn1點擊事件時對應的函式-onClick放入至Callback Queue，接著再點擊testbtn2時，瀏覽器會把testbtn2點擊時對應的函式-onClick放入至Callback Queue，然後隨著後續的點擊來把對應的函式放入至Queue，過程中，負責管理事件接收和處理的執行緒會把Queue的第一個函式放入至Call Stack來執行，隨後執行完就被移出，再挑下一個在Queue的函式，直到Queue被清空。<br><a target="_blank" rel="noopener" href="https://youtu.be/50zxZ7GawmA">點擊我看例子</a></p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>setTimeout 本身是瀏覽器的WebAPI所提供的定時器，當瀏覽器在JavaScript檔案讀取到以下格式時，便會呼叫WebAPI下的setTimeout來執行，此時瀏覽器會建立一個thread去按照secs秒數來等待，等到時間到的時候會把指定函式-funct 放入至Marcotask Queue或者CallBack Queue，而指定函式會跟其他上述提到的事件處理函式一樣，等到Call Stack為空才會將Queue的funct移到Main Thread來執行，而Call Stack會放上funct。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function funct() &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;, secs)</span><br></pre></td></tr></table></figure>

<ul>
<li>在這裡的CallBack Queue會是Marcotask Queue</li>
</ul>
<h3 id="setTimeout-例子1"><a href="#setTimeout-例子1" class="headerlink" title="setTimeout 例子1"></a>setTimeout 例子1</h3><p>設定一個等待1秒才執行的計時器，首先當瀏覽器的JavaScript引擎讀取到setTimeout和1000時，就便呼叫瀏覽器的WebAPI-setTimeout來建立一個thread來實現計時器，一開始會按照1000ms來等待，接著時間一到就把對應的函式-timeout放入至Callback Queue，然後等到Call Stack為空時，就把Queue中的timeout函式放到Main Thread來執行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout() &#123;</span><br><span class="line">    console.log(&#x27;delay 1 sec&#x27;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Hello!&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636826224/blog/event/eventloop/setTimeout1sec_s5m432.gif"></p>
<h3 id="setTimeout-例子2"><a href="#setTimeout-例子2" class="headerlink" title="setTimeout 例子2"></a>setTimeout 例子2</h3><p>設定一個等待0秒才執行的計時器，雖然看形式上會是先於顯示Hello，但實際上瀏覽器還得呼叫API來建立worker thread執行定時器、並按照時間將對應函式放入Callback Queue、等待Call Stack為空才能正式執行，所以基本上會慢於顯示Hello。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout() &#123;</span><br><span class="line">    console.log(&#x27;delay 0 sec&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Hello!&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636826230/blog/event/eventloop/setTimeout0sec_dkuv8i.gif"></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">Event dispatch and DOM event flow</a></li>
<li><a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/363397/how-does-an-event-listener-work">event: pull vs. push</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@tigranbs/concurrency-vs-event-loop-vs-event-loop-concurrency-eb542ad4067b">Concurrency vs Event Loop vs Event Loop + Concurrency</a></li>
<li><a target="_blank" rel="noopener" href="https://gameprogrammingpatterns.com/event-queue.html">Event Queue</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/librarylai/de189c3b53a3c6a24d40f2f6a10ee08c">Event loop、Call Stack 與 Task Queue</a></li>
<li><a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a target="_blank" rel="noopener" href="https://hackmd.io/@jwang0306/sehttpd">jserv 對於event loop + Thread pool的課程作業</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/10/15/frameworkIntro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/15/frameworkIntro/" class="post-title-link" itemprop="url">框架概念介紹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-15 21:31:13" itemprop="dateCreated datePublished" datetime="2021-10-15T21:31:13+08:00">2021-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>框架則是一種以某種開發環境A的不足地方再加以改良的開發環境B，從而提供不足的功能給開發者，而開發環境B會以自己專屬的概念、語法、功能來提供，這些概念、語法、功能將會對應開發環境A的原有概念、語法、功能以及額外包覆著其他模組，開發者只需要在被開發環境B封裝的環境下進行想要的開發，最後會由於開發者的程式碼被開發環境B封裝的關係而先讓開發環境B先被執行，然後再由它來決定開發者的程式碼何時能被執行，換言之，你實際的應用程式是被一個另一個程式(開發環境B)包含住，然後這個程式可以為你的應用程式提供許多支援性，只是每當執行時，就會先以這個程式來執行，等這個程式需要你的應用程式時才會由程式去呼叫。</p>
<p>另外，由於該環境B為了改良而以著專屬的語法、概念、功能來對應原有環境下的概念、語法、功能，所以會以這樣的特性自成一個體系、框架、結構等，所以才以框架來稱呼。</p>
<h2 id="後端框架-vs-函式庫"><a href="#後端框架-vs-函式庫" class="headerlink" title="後端框架 vs 函式庫"></a>後端框架 vs 函式庫</h2><p>函式庫是一種存放可重用性高的程式碼、函式、類別的儲存庫，可以藉由函式庫呼叫來實現相同類似功能的程式碼來執行，不必額外花時間去重新打造相同的程式來增加開發效率，而這些程式碼通常會由許多開發者構築而成的，你可以自己決定什麼時候使用儲存庫下的程式碼以及使用什麼樣程式碼。</p>
<p>對於不必重新打造相同類似的功能而言，框架可以在某一種程度上能做得到，但是其本身是另一套擁有專屬語法、概念、功能的開發環境，所以本質上無法讓開發者自由自在去調用框架下所提供程式碼，開發者必須遵守框架所定下的語法、概念才能被執行，而執行方面會是由框架來呼叫開發者的程式碼，而非像函式庫那樣，由開發者去呼叫函式庫的程式碼。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1634139009/blog/SE/frameworkVSLibrary_twgjx3.png"></p>
<h2 id="用語介紹"><a href="#用語介紹" class="headerlink" title="用語介紹"></a>用語介紹</h2><ol>
<li>框架(Framework)和函式庫(Library)可以用工具包來形容他們，而工具包本身意思就是將多個模組&#x2F;多種不同程式碼封裝成一個空間，形容工具包的英文可以是Package、Library、Module 來形容，其中Package在Javascript社群中特別常形容這兩者，另外部分用語可能無法通用於兩者，比如Library和Framework本質上並不能劃上等號。</li>
<li>Package的原意為被紙包覆住的物件，在這裏可以指被用另一個開發環境包覆住開發者的程式碼的框架、程式碼被封裝在一起的函式庫(Library)</li>
<li>例子：Bootstrap、Font Awesome、Axios</li>
</ol>
<ul>
<li>我們運用 Bootstrap 來做出風格一致的網站樣式</li>
<li>我們用 Font Awesome 來做 icon</li>
<li>我們用 Axios 來發送 Ajax 請求</li>
</ul>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/">The Difference Between a Framework and a Library</a></li>
<li><a target="_blank" rel="noopener" href="https://www.programcreek.com/2011/09/what-is-the-difference-between-a-java-library-and-a-framework/">Library vs. Framework?</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/10/03/indent2TextNode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/03/indent2TextNode/" class="post-title-link" itemprop="url">縮排會構成文字節點</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-03 23:45:21" itemprop="dateCreated datePublished" datetime="2021-10-03T23:45:21+08:00">2021-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>當瀏覽器去解析HTML檔案時會根據讀取到的內容所具有的特徵來判定該內容是屬於什麼種類的節點，而剛好縮排(換行和空白)會被瀏覽器當作一般文字並轉化成文字節點，這情況時常發在標籤之間的縮排，拿下圖的程式碼作為例子，其中&lt;ul&gt;和&lt;li&gt;之間存在著”\n      “，而&lt;li&gt;之間也存在同樣的縮排</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li&gt;sugar&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;cocoa&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>這會使DOM Tree多產生幾個存放縮排內容的文字節點(如下圖)，而這樣的節點有可能會影響著DOM節點的遍歷，且會增加渲染過程的成本。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633275050/blog/dom/additionalTextNode_vvbtiu.png"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>由於是因爲出現縮排內容才額外產生存放縮排內容的文字節點，因此只要把縮排刪除就能解決，但這樣會對易讀性有所影響，因此實務上會在正式發佈網站前，會採用一種自動化工具能將文件裡的縮排全部取消，而這個程序稱為 Minify，取消後的縮排也會使檔案縮小，另外這程序也時常在一般專案出現，比如Bootstrap的函式庫裡都會含有min檔名，那是經過 Minify 程序的檔案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/10/03/attVSpro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/03/attVSpro/" class="post-title-link" itemprop="url">HTML屬性 VS. 物件屬性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-03 22:12:40" itemprop="dateCreated datePublished" datetime="2021-10-03T22:12:40+08:00">2021-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:33" itemprop="dateModified" datetime="2022-03-18T00:06:33+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="導覽簡介"><a href="#導覽簡介" class="headerlink" title="導覽簡介"></a>導覽簡介</h2><p>首先先來考慮原有文字的含義，接著分別介紹著HTML屬性和物件屬性，最後再說明HTML經過轉變化的屬性又是如何變化。</p>
<h2 id="這兩者間文字含義"><a href="#這兩者間文字含義" class="headerlink" title="這兩者間文字含義"></a>這兩者間文字含義</h2><p>HTML的屬性是用attribute來表達，而物件的屬性則是用property來表達，雖然這兩者在中文翻譯上是表達屬性，但真正含義都是在原文是如何表達他們，前者的attribute是指附加至元件&#x2F;物件&#x2F;物體的額外資訊，這些資訊通常會強調著元件&#x2F;物件&#x2F;物體 “具有” 什麼樣的功能或者什麼樣性質，不會被特意強調元件&#x2F;物件&#x2F;物體本來就會有的，而後者的property是指著元件&#x2F;物件&#x2F;物體上的原有特性，比較強調著物件 “本來就會有” 的性質。</p>
<h3 id="在程式語言上的含義"><a href="#在程式語言上的含義" class="headerlink" title="在程式語言上的含義"></a>在程式語言上的含義</h3><p>在程式語言上，HTML本身利用標籤和內容來呈現網頁的呈現，標籤正是網頁的元件，為了進一步呈現更豐富更自由的網頁內容，而添加資訊(比如href、src、id、classu)至標籤上，使瀏覽器知道透過這些資訊來改變元件的特性，而這些額外資訊正是attribute，在這裡我們可以將attribute稱之為元件屬性，然而沒用property來描述是因為這些資訊本來就不是這些元件與生俱來的，比較像是額外添加給的功能或者特性。</p>
<p>而物件導向語言是以一個物件的角度來開發程式，過程中會為了更充分表達物件 “原有” 的特性和行為，而選擇property來描述屬性，但若選擇attribute就沒特意強調著屬性是這個物件所與生俱來的特性，只是單純附加給這些物件一些資訊來描述特性。</p>
<h2 id="HTML屬性"><a href="#HTML屬性" class="headerlink" title="HTML屬性"></a>HTML屬性</h2><p>根據描述，HTML的屬性(attribute)只不過是附加網頁元件的額外資訊，因此我們可以在對應元件的標籤添置一些資訊，形式會是如下的attributeName和attributeValue，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag attributeName=attributeValue&gt;</span><br><span class="line">  content</span><br><span class="line">&lt;/tag&gt;</span><br></pre></td></tr></table></figure>
<p>前者是指定屬性名稱，後者則對應名稱的值，屬性名稱沒有大小寫之分並一律當作小寫來看待，因此你寫上大寫的ID，都會被當作id，而對應值在大部分情況下是字串值，名稱和對應值可以在滿足前面所述的規定下寫出與對應元件無關的名稱和值。但為了進一步利用屬性值來呈現更豐富的網頁效果，部分的屬性名稱被HTML標準化成每個元件皆擁有不同的屬性(attribute)，而這些屬性能夠若被瀏覽器辨識到會使對應的元件展現出額外的效果，而其餘屬性名稱則沒有任何效果。</p>
<h2 id="物件屬性"><a href="#物件屬性" class="headerlink" title="物件屬性"></a>物件屬性</h2><p>物件導向語言中的物件所擁有的屬性(property)如同字面上的定義，會是描述物件原有的特性或者性質，通常會是以key-value pair的形式來表示屬性和屬性值，在JavaScript中，我們可以透過其動態語言特性在內容額外添加某個物件上的屬性或者事先定義一個物件會有屬性，形式上通常會是以下兩種，其中property則是屬性，而value是對應屬性的屬性值，第一種形式是透過內容額外添加屬性，第二種形式則是事先定義一個物件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">obj.property = value</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  property: value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="HTML轉變成DOM後"><a href="#HTML轉變成DOM後" class="headerlink" title="HTML轉變成DOM後"></a>HTML轉變成DOM後</h2><p>當瀏覽器載入頁面時，會讀取(解析)網頁並將網頁上的每一個HTML元件轉化成DOM節點或者DOM物件，而每個HTML元件上都有特定被標準化的屬性(attribute)來讓瀏覽器進一步辨識以及元件呈現，同樣地，這些被標準化的屬性在HTML元件轉化成DOM物件的過程中，瀏覽器會直接將標準化的屬性(attribute)和屬性值(attribute value)轉化成對應物件的屬性(property)以及屬性值(property value)，也就是說我們可以用物件的形式來表達那些attribute所帶有的額外資訊，比如說HTML元件為如下元件，轉化後的物件是body，其id屬性(attribute)本身因為為標準化的屬性(attribute)，所以會直接變成body物件的屬性(property)，而屬性(property)名稱會是原本的屬性(attribute)名稱，也就是body.id，而該屬性值會是”page”這內容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body id=“page”&gt;</span><br></pre></td></tr></table></figure>

<p>而不是標準化的屬性(attribute)則會因為瀏覽器無法辨識而不直接轉化成對應物件的屬性(property)，而這些案例通常是：</p>
<ol>
<li>屬性名稱未能夠正常辨識：something是這案例所要使用的屬性名稱，在這裡由於其名稱既不是body元件會有的屬性名稱，更不是正常會有的屬性名稱，所以無法被辨識</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body id=&quot;test&quot; something=&quot;non-standard&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>同個能辨識出來的屬性名稱在其他不存在該屬性的元件使用：其中type是這案例所要使用的屬性，在input元件上因為它存在type這屬性名稱，所以能夠正常辨識，而body元件則是不存在type這屬性名稱，所以無法被辨識</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body id=&quot;body&quot; type=&quot;...&quot;&gt;</span><br><span class="line">  &lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>


<p>最後，瀏覽器會提供一個能夠存取DOM Tree的介面給想要存取它的程式語言，比如JavaScript，該語言只要一從這個介面來獲取DOM物件時，會直接轉化成JavaScript能夠辨識的物件型別，同時間也會把該物件所擁有屬性值(property)轉化成程式語言能夠存取的型態。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.researchgate.net/post/What-are-the-differences-between-attribute-and-properties">attribute vs. property</a></li>
<li><a target="_blank" rel="noopener" href="https://javascript.info/dom-attributes-and-properties">Attributes and properties</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/10/02/AC21FeedBack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/02/AC21FeedBack/" class="post-title-link" itemprop="url">AC 學習心得</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-02 15:53:30" itemprop="dateCreated datePublished" datetime="2021-10-02T15:53:30+08:00">2021-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:33" itemprop="dateModified" datetime="2022-03-18T00:06:33+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="出身背景"><a href="#出身背景" class="headerlink" title="出身背景"></a>出身背景</h2><p>首先我原本就是資訊工程學系出身，擅長領域為作業系統和虛擬化，就在碩士班畢業後，原本可以好好當一名稱職的工程師，但那時想法卻不是想這樣安然度過往後的人生，所以做了不少看起來像是傻瓜會做的事情，比如與朋友創業，創業失敗時發現父母身體狀態變差，就回台邊照顧著他們邊以“智慧是什麼”來當作人工智慧的研究主題，並以此來當作求讀博士班的準備，但幾年後，父親死了，母親的精神狀況又變得更差，所以花更多時間去著手觀察母親的狀況以及父親的後事處理(含法事)，怕她想不開而了結自己，過程中還是仍沒停下研究的路徑，只是變得很慢，甚至評估要花更多年的時間去完成，而這樣又會怕這樣耽誤自己的未來無法找到工作。</p>
<h2 id="轉折點"><a href="#轉折點" class="headerlink" title="轉折點"></a>轉折點</h2><p>不過好在母親的精神狀況恢復許多，這正好給予機會讓我先停下一切的研究進度，先著手計畫找到一份工程師的工作來解決未來沒有工作的擔憂，但又擔心著自己已經有一些時間沒寫程式以及花更多時間去著手準備，正巧有個人對我在medium平台上的文章做出了迴響，我點開這個人的介紹以及文章，發現非本科生利用Alpha Camp平台上在短時間內學習並轉職成網頁工程師，這時我就試想著我能不能也利用平台來在短時間內轉職，所以我搜尋並比較類似於Alpha Camp的平台與Alpha Camp哪一個平台比較適合引導我走向正確的轉職路線，最後我以(比較能夠引導人學習到業界所需的知識和技術)引導性較強和(能與其他人交流程式碼)社交性較強的Alpha Campe平台來作為轉職的出發點。</p>
<h2 id="在AC學期一的學習"><a href="#在AC學期一的學習" class="headerlink" title="在AC學期一的學習"></a>在AC學期一的學習</h2><p>一開始我先進入學期一來試著恢復自己以往的寫程式能力以及如何寫程式，在那之前，我自己認為我應該很難完成一個網頁，但學期一的引導式學習以及助教的鼓勵讓我完成一個網頁的開發，這讓我對網頁開發有更多的自信，甚至對它有更多興趣，隨後平台上舉辦著同期生視訊交流的活動，在那裡與其他同期生交流著如何轉職、為何選擇AC、轉職出發點是什麼，這活動的確讓我收穫許多，特別是大家都一致認定AC提供的幫助是足夠的，這給予我足夠信心去選擇AC雙打計畫來學習後面學期的內容。</p>
<h2 id="在AC學期2-1的學習"><a href="#在AC學期2-1的學習" class="headerlink" title="在AC學期2-1的學習"></a>在AC學期2-1的學習</h2><p>進入學期2-1之後，那時是預讀的狀態，我預覽著內容難度都跟學期一的難度是不同層級的，學到的知識和技術也是更深入更有趣的，特別是網頁還能轉化DOM來讓JavaScript去操作它們，這讓我覺得很有趣，原來這就是使用者與網頁之間的核心之一，我進一步利用這體驗來研究DOM以及試著用自己的話來解釋DOM是什麼、我們能做些什麼，到了後頭事件處理的章節，這讓我更有興趣，因為這讓我回到當初在學校用Java開發軟體的愉悅心情，整體的預讀體驗是讓我愉快又充實，不過我也發現自己有著金魚腦，所以又做了不少筆記以及學習如何學習，等到正式轉到學期2-1時，我給予我自己一個目標-要比預讀的我更進步，所以我試著優化了不少作業，助教們也很認真去觀察作業還能改良什麼，雖然多少會有失落感，但學到的東西卻比預讀時期的我來說還要更多，我多學到了解構、如何進一步優化程式碼、如何不使用z-index來完成相同的事情等等新知和技術，另外工作坊也給予不少心靈雞湯以及我所不知道的開發細節，真的蠻謝謝各位助教，沒有他們說不定很難持續下去，但只可惜學期2-1的內容就只到這邊就結束，所以我繼續往下一個學期預讀，再做一次同樣的事情、筆記、優化，希望能透過這份興趣來轉職我想要當的網頁工程師，當然或許我會真的完全停掉先前的研究計畫，全心全力投注在網頁開發上，畢竟這對我來說是份有趣的事情。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Eklipsorz"
      src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
  <p class="site-author-name" itemprop="name">Eklipsorz</p>
  <div class="site-description" itemprop="description">Success is nothing more than a few simple disciplines, practiced every day.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eklipsorz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eklipsorz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eklipsorz@protonmail.ch" title="E-Mail → mailto:eklipsorz@protonmail.ch" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eklipsorz</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
