<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eklipsorz.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sloth Engineer">
<meta property="og:url" content="https://eklipsorz.github.io/page/2/index.html">
<meta property="og:site_name" content="Sloth Engineer">
<meta property="og:description" content="Success is nothing more than a few simple disciplines, practiced every day.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Eklipsorz">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eklipsorz.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sloth Engineer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sloth Engineer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/09/10/typeCheckingAndCoercion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/typeCheckingAndCoercion/" class="post-title-link" itemprop="url">JS - 型別檢查與隱性轉換</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 00:33:37" itemprop="dateCreated datePublished" datetime="2021-09-10T00:33:37+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:36" itemprop="dateModified" datetime="2022-03-18T00:06:36+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>型別檢查(Type checking) 會是校驗變數&#x2F;結構的型別是否符合內容，並回報錯誤或者幫助系統確定變數型別確實是如此，主要是盡可能偵測相關問題並及時給予機會去修正。</p>
<h2 id="型別檢查什麼時期執行"><a href="#型別檢查什麼時期執行" class="headerlink" title="型別檢查什麼時期執行"></a>型別檢查什麼時期執行</h2><p>型別檢查會發生在編譯期間或者執行期間，若是在編譯期間進行檢查的話，代表所有的程式碼都必須在執行前或者更早之前指定型別給會用到的變數和內容，而開發者可以選擇在開發期間指定型別給每個變數和內容，並在編譯期間讓編譯器去做型別檢查做第二輪的檢查，或者也可以不用開發者去指定，讓編譯期間的編譯器根據內容去做檢查，通常會選擇前者，比較能夠透過額外的資訊和第一輪檢查(開發者)增加型別的正確性。</p>
<p>而若是在執行期間進行檢查的話，代表所有程式碼都是在執行時根據指派內容和一些指派規則來確定變數和內容各是什麼樣的型別，當然地，型別確定可以不限於第一次的型別檢查，還有可能會是根據每次指派內容而變動相同變數的型別，比如說變數a第一次做型別檢查時，是被判定為數字型別，而接著a儲存字串資料，而這時會做二次型別檢查，使變數a轉變為字串型別。</p>
<h2 id="靜態語言與動態語言"><a href="#靜態語言與動態語言" class="headerlink" title="靜態語言與動態語言"></a>靜態語言與動態語言</h2><p>若某程式語言是在編譯期間進行型別檢查的話，該程式語言會是靜態語言(Statically Typed Languages)；若某程式語言是在執行期間進行的話，該程式語言會是動態語言(Dynamically typed languages)。</p>
<h2 id="JavaScript-是屬於？"><a href="#JavaScript-是屬於？" class="headerlink" title="JavaScript 是屬於？"></a>JavaScript 是屬於？</h2><p>JavaScript由於本身是透過直譯器來執行，無法在編譯時期執行型別檢查，只能選擇在執行期間進行型別檢查以及確定型別，因此它屬於動態語言，JavaScript會根據 “每一次” 的指派內容來指定 “每一次” 的型別檢查和確定型別，這也就是一個變數型別可以根據內容而轉換為JavaScript任意可辨識的型別，使得開發者變得更好開發，但對於結果來說，會容易產生出預期以外結果，比如說由表達式所構成的一個值或者一個物件，該表達式可能有不少的變數、常數、運算符號，其形式會是：var1至varN是變數，constant1至constantN是常數，operator1至operator(N-1)是運算符號，這些參數會構成足以代表一個值或者一個物件的表達式，並將代表的內容傳進value1這變數</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let value1 = var1/constant1 operator1 var2/constant2 ...... operator(N-1) varN/constantN</span><br></pre></td></tr></table></figure>

<p>若這些變數和常數的型別皆為一樣時，我們很容易預估最後結果的型別以及value1變數型別是什麼，但是如果某些變數或者常數的型別是不太一樣時，這時我們就很難預估型別是什麼，得依賴著直譯器對於他們的判定。</p>
<h3 id="型別轉換-Type-Conversion"><a href="#型別轉換-Type-Conversion" class="headerlink" title="型別轉換(Type Conversion)"></a>型別轉換(Type Conversion)</h3><p>直譯器遇到這些不同型別的變數或者常數時，你可以選擇添加一些轉換型別的語法來為這些變數和常數進行顯性轉換(Type Casting)，但若不添加的話，就是由直譯器負責處理隱性轉換(Type Coercion，不透過較明顯的轉換語法)，而隱性轉換會根據直譯器內部的轉換規則來進行，比如說它會從表達式抽出最優先計算的一部分表達式，通常會是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var1/constant1 operator1 var2/constant2</span><br></pre></td></tr></table></figure>

<p>並且檢查var1&#x2F;constant1 和var2&#x2F;constant2哪一邊是字串，若有字串，整條表達式會以字串形式來進行並以字串來輸出，接著就是按照operator的性質來決定非字串的資料要如何隱性轉換。</p>
<h4 id="已知的隱性轉換規則"><a href="#已知的隱性轉換規則" class="headerlink" title="已知的隱性轉換規則"></a>已知的隱性轉換規則</h4><p>加法比較特別一點，它會試著將用到的參數轉換成字串來串連或者以數值系統的加法來處理，目前已知的轉換規則是：</p>
<ol>
<li>當兩邊皆能夠用數字表示時，比如false、null，會用數值系統的加法</li>
<li>若其中一邊為物件時，會用字串形式來串連</li>
</ol>
<p>若是operator是能處理數字的加減乘除的話，那麼就是按照數字型別來隱性轉換，比如：</p>
<ol>
<li>100 + false 就會是</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 + Number(false) = 100 + 0 = 100</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>99 + null + 1 就會是</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 + Number(null) + 1  = 99 + 0 + 1 = 100</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>99 + true + NaN 就會是</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 + Number(true) + Number(NaN)  = 99 + 1 + NaN = NaN</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>99 + true + undefined 就會是，其中Number的參數若不是正常數字時就會是NaN</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 + Number(true) + Number(undefined)  = 99 + 1 + NaN = NaN</span><br></pre></td></tr></table></figure>




<h3 id="避免隱性轉換的開發建議"><a href="#避免隱性轉換的開發建議" class="headerlink" title="避免隱性轉換的開發建議"></a>避免隱性轉換的開發建議</h3><ol>
<li>使用顯性轉換</li>
<li>要比較內容時，請使用&#x3D;&#x3D;&#x3D;&#x3D;或者!&#x3D;&#x3D;，別使用&#x3D;&#x3D;或者!&#x3D;，這會使直譯器繼續使用隱性轉換</li>
</ol>
<h2 id="補充資料："><a href="#補充資料：" class="headerlink" title="補充資料："></a>補充資料：</h2><ol>
<li>型別轉換(Type conversion)可以是顯性或者隱性轉換，若是顯性轉換的話，會透過較明顯的轉換語法來達到型別轉換，直接由開發者自行決行轉換什麼型別，比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(100 + Number(false))          // 100 + 0 = 100</span><br></pre></td></tr></table></figure>
<p>而若是隱性轉換的話，就如同前面所述，不會透過明顯語法來達到目標，而是由直譯器來決定型別是什麼，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(100 + false)                  // 100 + 0 = 100</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p>可以透過顯性轉換轉換為true&#x2F;false、數字0&#x2F;1：<br>a. 可在boolean系統轉換為true的內容，有非空內容的字串(包括’0’)、非0的數字、非Null物件。<br>b. 可在boolean系統轉換為false的內容，有空字串、0、NaN、null、undefined、false。<br>c. 可轉換數字的內容，有具有數字的字串、boolean值、空字串</p>
</li>
<li><p>當if&#x2F;else條件式、while、for等具有boolean條件式(用boolean值的true和false判定條件成立)使用“原本可在顯性轉換中能轉換為true&#x2F;flase”的資料作為條件式且只有單一值&#x2F;單一物件時，其直譯器會以隱性轉換將這些資料轉換，其結果會如同使用顯性轉換下的結果。比如說：設定testVar為NaN，當進入if的條件式中，直譯器就會以Boolean(testVar)來轉換，最後會獲得false進入else來印I’m false。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let testVar = NaN</span><br><span class="line">if (testVar) &#123;</span><br><span class="line">    console.log(&#x27;I\&#x27;m true&#x27;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;I&#x27;\m false&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion">https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8857763/what-is-the-difference-between-casting-and-coercing">https://stackoverflow.com/questions/8857763/what-is-the-difference-between-casting-and-coercing</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/09/09/jsScope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/jsScope/" class="post-title-link" itemprop="url">JavaScript - Scope 簡介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-09 17:47:19" itemprop="dateCreated datePublished" datetime="2021-09-09T17:47:19+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在程式語言中，作用域(Scope)是指對應某種實體(entity)的名字(name)所能夠被合法辨識以及使用的範圍，其中實體是指的是某種記憶體區塊，而名字就是變數(variable)名稱，換言之，只要我們透過變數名稱就能操控代表記憶體區塊的實體。在這裡皆以let、const這些不違反Scope規則的變數宣告方式，var宣告會另開一個小節做說明</p>
<h2 id="Scope-有哪些種類？"><a href="#Scope-有哪些種類？" class="headerlink" title="Scope 有哪些種類？"></a>Scope 有哪些種類？</h2><p>Scope可以是由{}所構成的範圍以及未被{}所構成的範圍，他們的形式通常分別會是如下：首先是由{}所構成的範圍，這個範圍又被稱之為區塊(Block)，其構成必須藉由開發者自行設定才會產生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    statement1 / expression 1</span><br><span class="line">               .</span><br><span class="line">               .</span><br><span class="line">               .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一個則是不用括號</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">statement1 / expression 1</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>預設上若沒特定添加{}的話，變數所在的作用域會是在不用括號的範圍，在這個範疇中會是全域作用域(Global Scope)，而括號構成的範圍只會出現全域作用域內部，對全域作用域而言，該範圍會是區域作用域(Local Scope)，其中根據全域作用域內包含區域作用域，我們可以將全域作用域成這個區域作用域的Parent Scope，而這區域作用域會是全域作用域的Child Scope，當然我們也可以在區域作用域內建立另一個區塊，形成另一種Parent-Child之間的作用域，若再進一步區分的話其中最根源或者包含所有區域作用域的作用域會是Root Scope，而這個作用域正是全域作用域。</p>
<p>現在我們知道預設上我們會在Root Scope進行宣告以及定義變數，在這裡所宣告的變數所擁有的作用域會是Root Scope或 Global Scope，而此變數會被稱之為全域變數，若跳脫Scope的範圍或者執行完畢時，其變數所佔用的記憶體會被釋放，若是在Root Scope內部產生另一個Scope並進行變數宣告的話，其額外產生的Scope對於Global Scope而言會是Local Scope，在那裡宣告的變數所擁有的Scope會只有那區塊，而不是Root Scope，而且該變數只要跳脫那Scope，它所佔用的記憶體空間會被釋放掉。</p>
<p>比如首先我們先替Root Scope取名為Scope A，其內部再產生一個名為Scope B的Scope，括號內部又宣告了一個變數b，其變數b的Scope只有括號內部而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line"></span><br><span class="line">    let b = 20</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在這情況下的變數b會被稱作為區域變數，且該Scope A對於由括號構成的Scope B而言，Scope A會是他的Parent Scope，而Scope B會是Scope A的Child Scope。若我們繼續沿用上面例子中的Scope B內產生另一個名為Scope C的Scope的話，也就是如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其Scope C會是Scope B的Parent Scope，而Scope C則會是Scope B的Child Scope。</p>
<h2 id="Root、Parent、Child這三者下的變數存取關係"><a href="#Root、Parent、Child這三者下的變數存取關係" class="headerlink" title="Root、Parent、Child這三者下的變數存取關係"></a>Root、Parent、Child這三者下的變數存取關係</h2><p>若我們把這些括號給去除掉的話，實際上還是同一個作用域下的變數，後面變數可以存取前面已宣告的變數值，只是現在我們只是單純按照括號賦予他們特定的作用域，進而告訴變數什麼時候該自己釋放記憶體，否則若不釋放會因為被判定成不屬於它原本的作用域而出錯。在這樣規則下，我們可以得知二件事：1. 變數宣告的先後順序仍沒改變，後面變數可以存取前面已宣告的變數，2. 變數所在的作用域會影響著它們何時釋放，接著我們將利用這兩套被推斷的規則以及例子來得知Root、Parent、Child這三者下的變數存取關係是什麼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line"> // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">     // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在這小節中，會以三個小例子來說明存取關係是如何，而這些例子分別可以推斷出</p>
<ol>
<li>無法在Parent Scope存取Child Scope所定義的變數。</li>
<li>Child Scope 能夠存取位於Parent Scope的變數，但前提必須看要存取的變數是否在Child Scope之前。</li>
<li>多個Parent Scope是相同的Child Scope是無法存取彼此間的變數。</li>
</ol>
<h3 id="例子：無法在Parent-Scope存取Child-Scope所定義的變數。"><a href="#例子：無法在Parent-Scope存取Child-Scope所定義的變數。" class="headerlink" title="例子：無法在Parent Scope存取Child Scope所定義的變數。"></a>例子：無法在Parent Scope存取Child Scope所定義的變數。</h3><p>繼續沿用上個例子，當想在Root Scope去印出Scope C下的變數或者Scope B的變數時，在只能待在Root Scope的前提下，只能有兩種選擇方式：a. 在Scope B前寫印變數的程式、b. 在Scope B後寫出印變數的程式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>這兩種選擇方式分別如下所示：</p>
<p>a. 在Scope B前寫印變數的程式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line">console.log(b)</span><br><span class="line">console.log(c)</span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>b. 在Scope B後寫出印變數的程式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(b)</span><br><span class="line">console.log(c)</span><br></pre></td></tr></table></figure>

<p>但這兩種方式皆無法正常印出變數b和變數c，a方式是因為變數b和變數c都還沒被宣告定義，所以本來就印不出來，而b方式則是因爲Scope內的所有變數的記憶體皆被釋放，所以也就跟著印不出來，同樣的概念也可以放在只考慮Scope B和 Scope C這兩者上，將他們兩者換成Parent Scope和Child Scope，當然最後結果會是沒辦法在Parent Scope存取到Child Scope下的變數。</p>
<h3 id="例子2-Child-Scope-能夠存取位於Parent-Scope的變數"><a href="#例子2-Child-Scope-能夠存取位於Parent-Scope的變數" class="headerlink" title="例子2: Child Scope 能夠存取位於Parent Scope的變數"></a>例子2: Child Scope 能夠存取位於Parent Scope的變數</h3><p>同樣地，若我們想要在Child Scope去存取Parent Scope下的變數，比如想在Scope B的範圍下印出Parent Scope的變數a，這時我們會因為Parent Scope的變數a還存在而能夠印出來。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20  </span><br><span class="line">    console.log(a)</span><br><span class="line"></span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但變數a的宣告定義是放在Scope B後頭的話，也就是像這樣，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Scope A: Root Scope</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">    </span><br><span class="line">    console.log(a)</span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let a = 10</span><br></pre></td></tr></table></figure>

<p>在這裡，對於Scope B而言，變數a的宣告定義會被系統認定為還未定義而無法被正常印出，這也代表宣告定義的先後順序會影響存取。 但若是在Child Scope之前就定義好要存取的變數，那麼可以在Child Scope來存取Parent Scope的元素。</p>
<h3 id="例子3-多個Parent-Scope是相同的Child-Scope是無法存取彼此間的變數"><a href="#例子3-多個Parent-Scope是相同的Child-Scope是無法存取彼此間的變數" class="headerlink" title="例子3: 多個Parent Scope是相同的Child Scope是無法存取彼此間的變數"></a>例子3: 多個Parent Scope是相同的Child Scope是無法存取彼此間的變數</h3><p>若我們考慮至少1個身在同個Scope的Child Scope，這些Child Scope彼此間的存取狀況會是如何？我們先繼續沿用上個例子來假設，首先我們在Scope B產生名為Scope D的Scope，現在我們有Scope C 和 Scope D，當我們想在Scope C存取Scope D的變數時，會因為宣告的先後順序而無法正常存取，而當我們想在Scope D存取Scope C下的變數時，我們會因為Scope C的變數已經被釋放掉而無法正常存取，換言之，Scope C 和 Scope D這兩者間無法彼此存取他們所擁有的變數。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Scope A: Root Scope</span><br><span class="line"></span><br><span class="line">let a = 10</span><br><span class="line"></span><br><span class="line">&#123; // Scope B: Child Scope of Root Scope</span><br><span class="line">    let b = 20 </span><br><span class="line">    </span><br><span class="line">    console.log(a)</span><br><span class="line">    &#123; // Scope C: Child Scope of Scope B</span><br><span class="line">        let c = 30</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; // Scope D: Child Scope of Scope B</span><br><span class="line">        let d = 40</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="補充資料"><a href="#補充資料" class="headerlink" title="補充資料"></a>補充資料</h2><h3 id="var-宣告過的變數"><a href="#var-宣告過的變數" class="headerlink" title="var 宣告過的變數"></a>var 宣告過的變數</h3><p>var的不同處在於var是ES5標準以前就有的關鍵字，ES標準越前面其嚴謹性會比較鬆散，這使得他的作用域上往往會出現預期以外的事情，比如使區域變數有可能會升格為全域變數，而let、const則是ES6標準出現的，其作用域上會嚴格根據宣告所在來決定，當宣告在全域出現，那就是全域變數；若出現在區域上，那就是區域變數。</p>
<p>另外部分未使用var&#x2F;const&#x2F;let來宣告變數時，該變數很有可能因為預設關係變成var性質的變數，比如在一般模式下執行以下程式碼，其變數x會變成var性質的變數x，進而因其性質而使該變數升格為全域變數。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use non-strict&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  for (x = 0; x &lt; 10; x++) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(x)                                  // 印出10</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="由括號所構成的區域作用域"><a href="#由括號所構成的區域作用域" class="headerlink" title="由括號所構成的區域作用域"></a>由括號所構成的區域作用域</h3><p>除了一般由兩個括號所構成的作用域以外，函式、迴圈等用上括號的結構，其性質上會是在由括號構成的作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    statement1 / expression 1</span><br><span class="line">               .</span><br><span class="line">               .</span><br><span class="line">               .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<p>a. 函式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line"></span><br><span class="line">    let testval = 10 </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    console.log(testval)        //result = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. 迴圈：其中statement1至3也是在括號內部構成的作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (statement1; condition1; statement3) &#123;</span><br><span class="line">    // run something</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以將for迴圈看作是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    statement1;</span><br><span class="line"></span><br><span class="line">    loop1:                      // loop1標籤</span><br><span class="line"></span><br><span class="line">    if (condition) &#123;            // 通常是條件式</span><br><span class="line">        //run something</span><br><span class="line">        statement3</span><br><span class="line">        continue loop1;         // 會直接跳回loop1標籤所在的地方執行</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同樣地，while迴圈和do-while迴圈內的條件式可以看作是括號內部所構成的作用域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (condition1) &#123;</span><br><span class="line">    // run something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">&#125; while (condition1)</span><br></pre></td></tr></table></figure>

<p>可以分別看作是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop1:                          // loop1標籤</span><br><span class="line">if (condition1) &#123;</span><br><span class="line">    // run something</span><br><span class="line">    continue loop1;             // 會直接跳回loop1標籤所在的地方執行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loop1:                          // loop1標籤</span><br><span class="line">// run something</span><br><span class="line"></span><br><span class="line">if (condition1) &#123;</span><br><span class="line">    continue loop1;             // 會直接跳回loop1標籤所在的地方執行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>參考資料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/var">https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/var</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.bitsrc.io/understand-scope-in-javascript-e150f889ba72">https://blog.bitsrc.io/understand-scope-in-javascript-e150f889ba72</a></li>
<li><a target="_blank" rel="noopener" href="https://8thlight.com/blog/jarkyn-soltobaeva/2017/06/13/scope-and-closures-in-javascript.html">https://8thlight.com/blog/jarkyn-soltobaeva/2017/06/13/scope-and-closures-in-javascript.html</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/09/07/lottaryFinalTask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/lottaryFinalTask/" class="post-title-link" itemprop="url">Simulate a Lottary game</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-07 21:19:17" itemprop="dateCreated datePublished" datetime="2021-09-07T21:19:17+08:00">2021-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:36" itemprop="dateModified" datetime="2022-03-18T00:06:36+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Website-Development/" itemprop="url" rel="index"><span itemprop="name">Website Development</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>該專案是以模擬樂透抽獎為主軸，開發者得要達成加密名字、加密電子郵件、產生樂透抽獎券號碼、抽出特定玩家賦予特定獎項、贏家公告、賦予參加獎給其他沒抽到的抽獎者等子功能，最後將這些功能組合成所要求的專案，而這些子功能必須滿足特定規格才算完成，另外會額外賦予測資方便調整，其測資以測資小節來說明。</p>
<h2 id="各子功能的開發規格"><a href="#各子功能的開發規格" class="headerlink" title="各子功能的開發規格"></a>各子功能的開發規格</h2><ol>
<li><p>加密名字： 前兩個字必須以明碼顯示，後續字元皆以<em>來表示，而後續字元數決定</em>的數量，比如Eklipsorz，那麼Ek以明顯顯示，除了前面兩個以外，後續有7個字元，所以用7個<em>來表示，將兩者結果結合成Ek</em>******。</p>
</li>
<li><p>加密電子郵件：電子郵件分為三個部分，使用者名稱、@符號、@後的後綴字，除了@和後綴字皆以明碼來顯示，使用者名稱必須隱藏後半段的字元，改由三個.符號來顯示，前半段則以明碼顯示，當使用者名稱的字元數是單數時，則一半的字元數將會是無條件捨去過後的數字，比如字元數是7，那麼一半的字元數則是3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half =  Math.floor(username.length / 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>產生樂透抽獎券號碼：xxyyyy這六個字元組成，xx是兩個大寫英文字母，而yyyy則是0~9這10個數字，每一組號碼都必須是獨立不重複的，另外可自由擴展大寫英文字母的數量以及數字的數量，比如3個大寫英文字母以及4個數字。</p>
</li>
<li><p>抽出特定玩家賦予特定獎項： 從抽獎名單中隨機挑一位抽獎者來擔任贏家，並賦予特定獎項，其中賦予形式必須是透過公告來告知。</p>
</li>
<li><p>贏家公告：公告指定抽獎者以及獲取獎項，公告形式是</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽獎券號碼 | 加密後的名字 | 加密後的電子郵件 | 獎項</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>賦予參加獎給其他沒抽到的抽獎者： 賦予參加獎給剩下沒抽到頭獎、貳獎、叁獎的抽獎者，賦予形式也必須是透過公告來告知。</li>
</ol>
<h2 id="測資"><a href="#測資" class="headerlink" title="測資"></a>測資</h2><p>測資會用一個物件陣列來存放每個抽獎者所擁有的資料(名字、電子信箱等)，其中過程中或許會替每個每個物件(抽獎者)增加一個抽獎券這個屬性值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const players = [</span><br><span class="line">  &#123; name: &#x27;Bernard&#x27;, email: &#x27;bernard@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Youchi&#x27;, email: &#x27;youchi@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Yenting&#x27;, email: &#x27;yenting@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Angela&#x27;, email: &#x27;angela@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Yvonne&#x27;, email: &#x27;yvonne@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Ellen&#x27;, email: &#x27;ellen@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Walter&#x27;, email: &#x27;walter@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Kevin&#x27;, email: &#x27;kevin@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Tim&#x27;, email: &#x27;tim@example.com&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Russell&#x27;, email: &#x27;russell@example.com&#x27; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="各子功能的實作"><a href="#各子功能的實作" class="headerlink" title="各子功能的實作"></a>各子功能的實作</h2><h3 id="加密名字實作"><a href="#加密名字實作" class="headerlink" title="加密名字實作"></a>加密名字實作</h3><p>主要實作一個名為encodeName的函式，功能會加密並回傳加密後的名字，會接受一個參數值，該值代表著未加密前的名字。其中參數本身string，但由於本身在JS上可以被當作String物件(這跟primitivie type的string名字相似，但實則上性質是不同的)來呼叫該物件特有的方法，比如substr和repeat，在這所用到substr會從第一個字元開始取，直到取到2個字元才停止，剛好可獲取明碼顯示的前兩個字元，後頭用上的<em>和repeat，則是利用</em>對於JS的型態的轉化去呼叫String物件的repeat方法，該方法會依照參數來複製字串內容並組成新字串，在這裏複製length - 2個*符號接在前兩個明碼字元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// encodeName(parameter1) 功能為加密接收到的名字</span><br><span class="line">// 參數說明： parameter1 是指要被加密的名字</span><br><span class="line">function encodeName (name) &#123;</span><br><span class="line">  // 以明碼顯示名字前兩個字元，後續字元全用*符號表示</span><br><span class="line">  return  name.substr(0, 2) + &#x27;*&#x27;.repeat(name.length - 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="加密電子郵件"><a href="#加密電子郵件" class="headerlink" title="加密電子郵件"></a>加密電子郵件</h3><p>主要實作一個名為encodeEmail的函式，功能會加密並回傳加密後的電子郵件，會接受一個參數值，該值會代表著未加密前的電子郵件。同樣地，這裡的參數同樣被當作String物件去調用indexOf、slice、repeat等方法，首先會用indexOfAtSign去獲取@在字串中的索引值，該值會是使用者名稱的字元數，接著利用這字元數進一步獲取一半字元數，並用floor方法去達到規格書的要求，現在我們有了這一半的字元數就能進一步加密，加密方式就用slice從參數的第0個索引值去擷取，ㄧ直到索引值為halfLengthOfUserName才停止擷取，接著在用.和repeat方法來產生3個.符號，最後則繼續用slice將@和@後綴字全曲出來，將這些擷取到的字串和產生出來的新字串結合在一起便是加密後的電子郵件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// encodeEmail(parameter1) 功能為加密接收到的email</span><br><span class="line">// 參數說明： parameter1 是指要被加密的email</span><br><span class="line">function encodeEmail (email) &#123;</span><br><span class="line">  // 請封裝你之前寫好的程式碼，並設計必要參數</span><br><span class="line"></span><br><span class="line">    // 找到@的索引值，而該值剛好是email使用者名稱的字元數</span><br><span class="line">    let indexOfAtSign = email.indexOf(&#x27;@&#x27;) </span><br><span class="line"></span><br><span class="line">    // 獲取email使用者名稱的一半字元數。</span><br><span class="line">    let halfLengthOfUserName = Math.floor(indexOfAtSign / 2)</span><br><span class="line"></span><br><span class="line">    // 使用 &quot;使用者名稱的一半字元以明碼顯示＋3個.符號＋@＋@後綴字&quot; 來組成加密後的email</span><br><span class="line">    let econdedEmail = email.slice(0, halfLengthOfUserName) + </span><br><span class="line">                       &#x27;.&#x27;.repeat(3)                        +</span><br><span class="line">                       email.slice(indexOfAtSign, email.length)</span><br><span class="line"></span><br><span class="line">    return econdedEmail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="產生樂透抽獎券號碼"><a href="#產生樂透抽獎券號碼" class="headerlink" title="產生樂透抽獎券號碼"></a>產生樂透抽獎券號碼</h3><p>主要實作一個名為generateTicketNumber的函式，功能上會產生獨立不重複的號碼給每個抽獎者，該函式會接受兩個參數，第一個參數是指定抽獎券的英文字母要填入多少個，第二個參數是指定抽獎券的數字(0~9)要填入多少個。該函式會透過無限迴圈的特性以及一組存放已產生且獨立不重複的清單ticketSet，一開始這個清單會是空陣列，無限迴圈會不斷產生號碼，過程成會不斷檢查目前產生的號碼是否能在ticketSet清單的號碼找到，能的話，代表是重複的，此時就會繼續產生下一組號碼來檢查；不能找到的話，則表示不為重複，這時會把號碼放入ticketSet中以及把號碼給抽獎者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let ticketSet = []</span><br><span class="line"></span><br><span class="line">// generateTicketNumber(parameter1, parameter2) 功能為產生獨立且不重複的抽獎</span><br><span class="line">// 券號碼給抽獎者，格式為xxxyyy，xxx代表要填入的英文字母，而yyy代表要填入的數字 </span><br><span class="line">// 參數說明：parameter1~2 是指定抽獎券的號碼格式分別要填多少個英文字母和數字</span><br><span class="line">function generateTicketNumber (literalLength, digitLength) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 利用無限迴圈的特性來不斷產生號碼，直到產生出獨立且不重複的號碼為止</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      </span><br><span class="line">        let ticket = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">        // 產生英文字母來填入號碼裡</span><br><span class="line">        for (let round = 0; round &lt; literalLength; round++) &#123;</span><br><span class="line">            ticket += String.fromCharCode(Math.floor(Math.random() * 26) + 65)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 產生數字來填入號碼裡 </span><br><span class="line">        for (let round = 0; round &lt; digitLength; round++) &#123;</span><br><span class="line">            ticket += Math.floor(Math.random() * 10)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ticketSet是存放所有已產生且獨立不重複的號碼，用它檢查新產生出來的號碼是否重複</span><br><span class="line">        if (!ticketSet.includes(ticket)) &#123;</span><br><span class="line"></span><br><span class="line">            // 將獨立不重複的號碼放到ticketSet</span><br><span class="line">            ticketSet.push(ticket)</span><br><span class="line">            return ticket</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="另一種解法"><a href="#另一種解法" class="headerlink" title="另一種解法"></a>另一種解法</h4><p>這是第一版的generateTicketNumber，原本的構想是想把會用到的參數、陣列全鎖定在一個函式內，盡量避免side effect，但由於do-while的實現會使ticketNumber變數宣告和指派過於累贅所以開發第二版。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function generateTicketNumber(players, literalLength, digitLength) &#123;</span><br><span class="line"></span><br><span class="line">       let ticketSet = []  </span><br><span class="line"></span><br><span class="line">       for (let player of players) &#123;        </span><br><span class="line">           let ticketNumber</span><br><span class="line"></span><br><span class="line">           do &#123;</span><br><span class="line"></span><br><span class="line">               ticketNumber = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">               for (let round = 0; round &lt; literalLength; round++) &#123;</span><br><span class="line">                   ticketNumber += String.fromCharCode(Math.floor(Math.random() * 26) + 65)</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               for (let round = 0; round &lt; digitLength; round++) &#123;</span><br><span class="line">                   ticketNumber += Math.floor(Math.random() * 10)</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; while (ticketSet.includes(ticketNumber))</span><br><span class="line"></span><br><span class="line">           player.number = ticketNumber</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>第二版的generateTicketNumber是出於修正變數宣告和指派變得累贅而修正，內容為以下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function generateTicketNumber(players, literalLength, digitLength) &#123;</span><br><span class="line"></span><br><span class="line">       let ticketSet = []  </span><br><span class="line"></span><br><span class="line">       for (let player of players) &#123;        </span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          while (true) &#123;</span><br><span class="line"></span><br><span class="line">              let ticketNumber =  &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">               for (let round = 0; round &lt; literalLength; round++) &#123;</span><br><span class="line">                   ticketNumber += String.fromCharCode(Math.floor(Math.random() * 26) + 65)</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               for (let round = 0; round &lt; digitLength; round++) &#123;</span><br><span class="line">                   ticketNumber += Math.floor(Math.random() * 10)</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (ticketSet.includes(ticketNumber) !== false) &#123;</span><br><span class="line">                    ticketSet.push(ticketNumber)</span><br><span class="line">                    player.number = ticketNumber</span><br><span class="line">                    break</span><br><span class="line">               &#125; </span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>但經由某些大師觀看並給予我2個建議，第一個是進一步利用includes(…)的true或者false來減少if的內容，比如說：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ticketSet.includes(ticketNumber) !== false) &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!ticketSet.includes(ticketNumber)) &#123;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一個建議可以更進一步實現避免side effect，具體方法就是把函式的參數縮減至1~2個或者使用解構方式來利用一個物件當參數，其物件的屬性就是實際的參數值，比如説：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function generateTicketNumber (&#123;players, literalLength, digitLength&#125;) &#123;       //宣告並定義generateTicketNumber</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generateTicketNumber(&#123;players, literalLength: 2, digitLength: 4&#125;)             // 呼叫generateTicketNumber</span><br></pre></td></tr></table></figure>


<p>但由於實際上的參數值players涉及到by reference且又是全域變數，即使改成這樣，仍避免不了side effect，所以得自行把函式和呼叫函式的形式改變成只需要1~2個參數值來實現相同的效果。為了避免最核心的清單被修改到，雖說有為抽獎者清單添增const，但那僅限於該變數的內容，而非參照位址對應到的記憶體空間，所以先捨棄players作為參數，但這樣又難以判斷目前產生的新號碼是否為重複，所以只好在額外添增一個全域陣列ticketSet來存放所有已產生且獨立不重複的號碼，讓函式內容去對它做更動:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ticketSet = []</span><br><span class="line"></span><br><span class="line">function generateTicketNumber (...) &#123;</span><br><span class="line">    ticketSet.push(something)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當然這也引發side effect，但運用該變數的函式和處理目前就generateTicketNumber本身，而先前的players陣列則是因為太多處理和函式用上它，權衡優劣性，只好拿全域陣列的辦法先捨棄players來實現第三版的函式，而第三版函式內容為如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const ticketSet = []</span><br><span class="line"></span><br><span class="line">// generateTicketNumber(parameter1, parameter2) 功能為產生獨立且不重複的抽獎</span><br><span class="line">// 券號碼給抽獎者，格式為xxxyyy，xxx代表要填入的英文字母，而yyy代表要填入的數字 </span><br><span class="line">// 參數說明：parameter1~2 是指定抽獎券的號碼格式分別要填多少個英文字母和數字</span><br><span class="line">function generateTicketNumber (literalLength, digitLength) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 利用無限迴圈的特性來不斷產生號碼，直到產生出獨立且不重複的號碼為止</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      </span><br><span class="line">        let ticket = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">        // 產生英文字母來填入號碼裡</span><br><span class="line">        for (let round = 0; round &lt; literalLength; round++) &#123;</span><br><span class="line">            ticket += String.fromCharCode(Math.floor(Math.random() * 26) + 65)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 產生數字來填入號碼裡 </span><br><span class="line">        for (let round = 0; round &lt; digitLength; round++) &#123;</span><br><span class="line">            ticket += Math.floor(Math.random() * 10)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ticketSet是存放所有已產生且獨立不重複的號碼，用它檢查新產生出來的號碼是否重複</span><br><span class="line">        if (!ticketSet.includes(ticket)) &#123;</span><br><span class="line"></span><br><span class="line">            // 將獨立不重複的號碼放到ticketSet</span><br><span class="line">            ticketSet.push(ticket)</span><br><span class="line">            return ticket</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而呼叫的形式則改成： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 幫每位抽獎者產生一組獨立不重複的抽獎券號碼，號碼預設填入2個大寫英文字母和4個數字</span><br><span class="line">for (let player of players) &#123;</span><br><span class="line">  player[&#x27;ticket&#x27;] = generateTicketNumber(2, 4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下修正：</p>
<ol>
<li>設定一個全域性質的陣列ticketSet，並設定空陣列</li>
<li>簡化了判定重複的條件式：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!ticketSet.includes(ticketNumber)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>讓最有爭議的players不成為參數，致使呼叫函式的引數之數量和函式參數之數量減少至2個</li>
</ol>
<h3 id="抽出特定玩家賦予特定獎項"><a href="#抽出特定玩家賦予特定獎項" class="headerlink" title="抽出特定玩家賦予特定獎項"></a>抽出特定玩家賦予特定獎項</h3><p>主要實作一個名為drawWinner的函式，功能會為從指定抽獎者清單抽出贏家並印出指定獎項和其贏家加密資訊，會接受兩個參數，第一個參數是存放所以抽獎者的清單，第二個參數是指定贏家會獲得什麼樣的獎項。當參數傳進去之後，會先透過random方法產生範圍為1~length(抽獎券人數)的亂數，以這個亂數來當抽獎名單的索引值，而挑出來的對應抽獎者就是贏家，另外再透過splice以該索引值來從清單直接取出，接著再把清單的對應抽獎者給刪去，以防止後續重複中獎，最後由這個贏家和第二個參數傳入announceMsg進行印出指定獎項和其贏家的加密資訊。雖說該參數也涉及到players這個具有爭議的陣列，但其函式內容本身不會更動其內容，只是單純讀取陣列內容，所以可以忽視side effect。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// drawWinner(parameter1, parameter2) 功能為從抽獎者中抽出一位贏家，並給予特定獎項，最後印出贏家資訊</span><br><span class="line">// 參數說明：parameter1 是指存放所有抽獎者的陣列，parameter2 是指定發放獎項是什麼</span><br><span class="line">function drawWinner (players, prize) &#123;</span><br><span class="line"></span><br><span class="line">  // 以亂數來抽獎</span><br><span class="line">  let winnerIndex = Math.floor(Math.random() * players.length) </span><br><span class="line">  // 按照winnerIndex找到對應的贏家</span><br><span class="line">  let winner = players.splice(winnerIndex, 1)[0]</span><br><span class="line"></span><br><span class="line">  // 印出贏家資訊</span><br><span class="line">  announceMsg(winner, prize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="贏家公告"><a href="#贏家公告" class="headerlink" title="贏家公告"></a>贏家公告</h3><p>主要實作一個名為announceMsg的函式，功能會依照指定贏家和指定獎項來印出其加密後資料和指定獎項，印出格式會依照規格書所定的那樣，該函式會接受兩個參數，第一個參數是指定贏家是誰，第二個參數是指定該贏家獲取的獎項是什麼。當參數傳進去之後，會直接透過console來進一步呼叫加密名字、加密電子郵件的函式來產生加密名字、加密電子信箱來分別印出抽獎券號碼、加密後的資訊、獎項。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// announceMsg(parameter1, parameter2) 功能為印出贏家資訊、獎項</span><br><span class="line">// 參數說明：parameter1 是指贏家，parameter2 是指定獲取的獎項是什麼</span><br><span class="line">function announceMsg (winner, prize) &#123;</span><br><span class="line">  // 印出贏家資訊、贏家獲取的獎項是為何</span><br><span class="line">  console.log(`$&#123;winner.ticket&#125; | $&#123;encodeName(winner.name)&#125; | $&#123;encodeEmail(winner.email)&#125; | $&#123;prize&#125;`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="賦予參加獎給其他沒抽到的抽獎者"><a href="#賦予參加獎給其他沒抽到的抽獎者" class="headerlink" title="賦予參加獎給其他沒抽到的抽獎者"></a>賦予參加獎給其他沒抽到的抽獎者</h3><p>經由drarWinner函式的處理可以把已中獎的人給剔除，那麼剩下來的抽獎者清單players就只剩下還沒中獎的人，所以在這裡直接透過for迴圈以及搭配現有的announceMsg函式直接賦予他們參加獎以及印出相關資訊。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let player of players) &#123;</span><br><span class="line">  announceMsg(player, &#x27;參加獎&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="主程式的呼叫方式"><a href="#主程式的呼叫方式" class="headerlink" title="主程式的呼叫方式"></a>主程式的呼叫方式</h2><p>首先會先產生獨立不重複的號碼給每位抽獎者，接著再透過三行drawWinder來抽三位贏家，按獲獎順序來分發頭獎、貳獎、叄獎，最後再分發參加獎給剩下沒參加獎的人</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 幫每位抽獎者產生一組獨立不重複的抽獎券號碼，號碼預設填入2個大寫英文字母和4個數字</span><br><span class="line">for (let player of players) &#123;</span><br><span class="line">  player[&#x27;ticket&#x27;] = generateTicketNumber(2, 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// draw 3 winners and announce the results</span><br><span class="line">drawWinner(players, &#x27;頭獎&#x27;)</span><br><span class="line">drawWinner(players, &#x27;貮獎&#x27;)</span><br><span class="line">drawWinner(players, &#x27;叁獎&#x27;)</span><br><span class="line"></span><br><span class="line">// the rest of players get participation award</span><br><span class="line">// write your code here</span><br><span class="line"></span><br><span class="line">for (let player of players) &#123;</span><br><span class="line">  announceMsg(player, &#x27;參加獎&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/29/DOM-OBJ-CreateInsertRemove/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/DOM-OBJ-CreateInsertRemove/" class="post-title-link" itemprop="url">DOM - Create-Insert-Remove for an object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-29 17:33:43" itemprop="dateCreated datePublished" datetime="2021-08-29T17:33:43+08:00">2021-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Website-Development/" itemprop="url" rel="index"><span itemprop="name">Website Development</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在這文章中，我們將簡介一個DOM物件是如何被建立、刪除、當成其他元素的子元素，而簡介內容將會以我目前所知的內容而定，後頭若有新的內容時，便會額外再增加內容。</p>
<h2 id="Create-an-Element"><a href="#Create-an-Element" class="headerlink" title="Create an Element"></a>Create an Element</h2><p>透過createElement方法來建立新的網頁元素newTag，並且利用innerHTML&#x2F;innerText賦予內容Content給其網頁元素，讓網頁元素在HTML形式中會像是下圖中那樣。在這小節中，我們將會簡介這些方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;newTag&gt;</span><br><span class="line">	Content</span><br><span class="line">&lt;/newTag&gt;</span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>document.createElement(tagName)<br>建立標籤名稱為tagName的元素節點，但在這個狀態下的元素節點並不會跟任何節點扯上parent或者child這些關係，就只是單純建立一個節點。</p>
<p>回傳形式：以元素節點進行回傳</p>
<h3 id="Assign-content-to-a-node"><a href="#Assign-content-to-a-node" class="headerlink" title="Assign content to a node"></a>Assign content to a node</h3><p>NODE.innerHTML &#x3D; value1<br>指定HTML內容value1給元素(節點)NODE，這相當於在該對應標籤內，指定value1為其標籤內部的內容，其內容會被重新以HTML形式來解析並產出新的DOM</p>
<p>NODE.innerText &#x3D; value1<br>指定內容value1給元素節點，這相當於在該對應標籤內，指定value1為其標籤內部的內容，但與innerHTML不同的事情就是不會被重新解析</p>
<h2 id="Traditional-Style-Insert-an-Element"><a href="#Traditional-Style-Insert-an-Element" class="headerlink" title="Traditional Style: Insert an Element"></a>Traditional Style: Insert an Element</h2><p>當我們透過createElement和innerHTML&#x2F;innerText來建立並指派一個新元素時，就只是單純在記憶體建立這個新元素且它並沒有任何父元素以及沒有任何子元素，這使得它無法在瀏覽器正常顯示，為了讓它能夠在瀏覽器正常顯示，必須讓該元素成為可顯示元素之下的子元素，但不會是其他元素的父元素，因為新元素本身是處在不可顯示的範圍內。</p>
<p>在本文中，我們先介紹瀏覽器是如何從讀取到的HTML內容來轉化成節點，並透過它來得知節點們是以何種形式來儲存，進而透過一些插入方法來說明一個新元素是如何被插入或者被當成可顯示的元素之下的子元素。</p>
<h3 id="How-the-browser-handles-some-new-nodes"><a href="#How-the-browser-handles-some-new-nodes" class="headerlink" title="How the browser handles some new nodes"></a>How the browser handles some new nodes</h3><p>預設上，瀏覽器會依據讀取的優先順序而決定某些子元素的存放順序，也就是說當瀏覽器讀取左邊的內容時，一開始讀取到element這標籤就建立element節點，接著又從標籤內發現content1這獨立內容(可以是另一個節點、文字、註解，但不會是類別屬性)，瀏覽器讀取到便建立屬於content1節點並當作是element元素的第一個子節點，而隨後讀取到的content2，便轉化成第二個子節點，後面依此類推。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630164255/blog/dom_Manipulation/file2DOM_tpcrw7.png"></p>
<p>後面新增的子節點將會放在子節點N(child node N)之後，另外，我們可以利用子節點存放方式以及存放順序，來建立一個類似於陣列的結構來存放這些子節點，並搭配index來方便存取特定子節點，在這裡瀏覽器有內建一些這樣子的物件來方便存子節點，比如NodeList以及HTMLCollection這兩種。</p>
<h3 id="Insert-an-Element-as-the-last-element"><a href="#Insert-an-Element-as-the-last-element" class="headerlink" title="Insert an Element as the last element:"></a>Insert an Element as the last element:</h3><p>parentNode.appendChild(newNode)：<br>將元素節點newNode當作是另一個元素節點parentNode的子節點，其子節點會放在目前子節點之後，也就是子節點N(child node N)之後，而新放入的子節點將會是子節點N+1(child node N+1)</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630164722/blog/dom_Manipulation/defaultAddNewNode_eon6un.png"></p>
<h3 id="Insert-an-Element-before-the-element"><a href="#Insert-an-Element-before-the-element" class="headerlink" title="Insert an Element before the element:"></a>Insert an Element before the element:</h3><p>parentNode.insertBefore(newNode, referenceNode)<br>將元素節點newNode當作是parentNode子節點，並放在另一個parentNode的子節點referenceNode之前，而child node N會是第N+1個子節點，</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630165095/blog/dom_Manipulation/insertBeforeNode_burnu5.png"></p>
<p>若子節點referenceNode不存在的話，會直接將節點newNode放到所有子節點之後，其動作等同於appendChild(newNode)。</p>
<h3 id="Replace-the-old-element-with-an-new-Element"><a href="#Replace-the-old-element-with-an-new-Element" class="headerlink" title="Replace the old element with an new Element:"></a>Replace the old element with an new Element:</h3><p>parentNode.replaceChild(newNode, oldNode)<br>將元素節點newNode當作是parentNode子節點，並將這個新的子節點取代掉另一個parentNode的子節點oldNode，而子節點oldNode將會被移除並釋放記憶體空間。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630166583/blog/dom_Manipulation/replaceChildNode_xhwsxd.png"></p>
<h2 id="Remove-an-Element"><a href="#Remove-an-Element" class="headerlink" title="Remove an Element"></a>Remove an Element</h2><p>當我們想要移除DOM上的某個元素時，可以使用以下的方法來實現，但這些方法只是單純從DOM上移除，而非是將整個元素從記憶體中移除，所以每當執行這些方法後，這些元素會以類似剛建立的元素一樣，待在記憶體中，等待成為其他元素的子元素。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630228692/blog/dom_Manipulation/removeResult_apsatq.png"></p>
<h3 id="Remove-a-child-node"><a href="#Remove-a-child-node" class="headerlink" title="Remove a child node"></a>Remove a child node</h3><p>Element.removeChild(NODE)<br>在DOM中，刪除Element下的子節點NODE，但實際上仍存在記憶體中等帶著下一次的新增。</p>
<h3 id="Remove-a-node"><a href="#Remove-a-node" class="headerlink" title="Remove a node"></a>Remove a node</h3><p>NODE.remove()<br>在DOM中，移除NODE節點，但實際上仍存在記憶體中等待著下一次的新增。</p>
<h2 id="Modern-style-Insert-an-element"><a href="#Modern-style-Insert-an-element" class="headerlink" title="Modern style: Insert an element"></a>Modern style: Insert an element</h2><p>近代的JavaScript有針對多個子元素推出幾個相關語法，這些語法與先前插入元素的方法-appendInsert、insertBefore、replaceChild相比，他們能夠接受多個子元素或者由多個元素所構成的元素集合當作參數來放入指定的地方，而先前的方法只能夠一次插入一個元素。另外由於語法上比較新，部分舊的瀏覽器很有可能無法支援較新版本的JS語法，比如IE瀏覽器。 </p>
<p>在這幾個方法中，我們將使用newNode set來當作每個方法的示例圖中的範例，而newNode set裡頭是由要被插入的多個新節點(node1至nodeN)所構成的集合。</p>
<h3 id="Insert-an-Element-before-the-element-1"><a href="#Insert-an-Element-before-the-element-1" class="headerlink" title="Insert an Element before the element"></a>Insert an Element before the element</h3><p>Element.before(node1, node2,….., nodeN):<br>將 node1 至 nodeN 這些節點設定為Element節點的parent節點所擁有的子節點，並將這些新的子節點放到Element節點之前，換言之，執行完之後，node1至nodeN這些節點就是Element節點的sibling 節點，且放在Element節點的前面。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630225558/blog/dom_Manipulation/beforeExample_tycheb.png"></p>
<h3 id="Insert-an-Element-before-the-first-child"><a href="#Insert-an-Element-before-the-first-child" class="headerlink" title="Insert an Element before the first child"></a>Insert an Element before the first child</h3><p>Element.prepend(node1, node2,…., nodeN):<br>將 node1 至 nodeN 這些節點設定為Element節點的子節點，並將這些新的子節點放到Element節點的第一個子節點之前。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630225557/blog/dom_Manipulation/prependExample_l69you.png"></p>
<h3 id="Insert-an-Element-as-the-last-child"><a href="#Insert-an-Element-as-the-last-child" class="headerlink" title="Insert an Element as the last child"></a>Insert an Element as the last child</h3><p>Element.append(node1, node2,…., nodeN):<br>將 node1 至 nodeN 這些節點設定為Element節點的子節點，並將這些新的子節點放到Element節點的最後一個子節點之後，其結果等同於for迴圈版本的appendChild： 其中node為 node1 至 nodeN，透過for迴圈將這些新節點放到後頭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let node of NewNodeSet) &#123;</span><br><span class="line">	Element.appendChild(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630225557/blog/dom_Manipulation/appendExample_gfbdyu.png"></p>
<h3 id="Insert-an-Element-after-the-element"><a href="#Insert-an-Element-after-the-element" class="headerlink" title="Insert an Element after the element"></a>Insert an Element after the element</h3><p>Element.after(node1, node2,…, nodeN):<br>將 node1 至 nodeN 這些節點設定為Element的parent節點所擁有的子節點，並將這些新的子節點放到Element節點之後，換言之，這些新的子節點就是Element節點的sibling節點，且放在Element節點之後。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630225557/blog/dom_Manipulation/afterExample_jxnc8j.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/28/DOM-OBJ-HowToManAttribute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/28/DOM-OBJ-HowToManAttribute/" class="post-title-link" itemprop="url">DOM - How To Manipulate Attribute From Object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-28 22:00:44" itemprop="dateCreated datePublished" datetime="2021-08-28T22:00:44+08:00">2021-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Website-Development/" itemprop="url" rel="index"><span itemprop="name">Website Development</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在JavaScript中，我們可以透過classList、style、className來更動對應網頁元素的樣式是為何，甚至可以依據某些事件發生而變動。在本文中，我們將簡介這些方法</p>
<h2 id="Node-Attribute-classList"><a href="#Node-Attribute-classList" class="headerlink" title="Node-Attribute: classList"></a>Node-Attribute: classList</h2><p>NODE.classList 指元素節點所擁有的屬性之一，其值會對應著具有live特性的DOMTokenList物件(註1)，該物件會儲存其對應元素使用的所有樣式名稱，每一個使用的樣式會以單獨一個元素儲存在DOMTokenList物件。</p>
<h3 id="classList-Object-Method"><a href="#classList-Object-Method" class="headerlink" title="classList Object: Method"></a>classList Object: Method</h3><p>NODE.classList.add(className1,…., classNameN)：對元素節點所擁有的DOMTokenList進行其他樣式名稱(className1,…classNameN)的增加，而被增加進來的樣式名稱會從DOMTokenList的尾部位開始放入，而參數量(可被放進去的樣式數量)則不限定於1~2個，可以按照開發者的需求而不斷放入。</p>
<p>另外要指定的類別名稱必須事先指定好該類別下所擁有的屬性以及其屬性值是為何，否則會<br>因為無法找到對應的類別名稱而設定預設樣式。</p>
<p>NODE.classList.remove(className1,…, classNameN)：從DOMTokenList物件刪除指定樣式名稱，而className1至classNameN則是依據開發者而定，沒限定於1~2個。</p>
<h2 id="Node-Attribute-className"><a href="#Node-Attribute-className" class="headerlink" title="Node-Attribute: className"></a>Node-Attribute: className</h2><p>NODE.className 屬性是指元素節點所採用的屬性(尤指類別)節點是什麼或者採用的選擇器是什麼，該屬性可允許開發者讀取和寫入，若元素節點NODE搭配多個類別，那麼其值會是下面形式來表示，每一個類別之間都會有空格作為間隔，這代表著對應元素使用著class1、class2、….、classN這幾個類別。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;class1 class2 ..... classN&quot;</span><br></pre></td></tr></table></figure>

<p>若要替元素節點NODE進行類別或者樣式的變更，則可透過相同規則來進行，另外，每一次的變更會連帶改變具有live特性的DOMTokenList物件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE.className = &quot;class1 class2 .... classN&quot;</span><br></pre></td></tr></table></figure>

<p>另外要指定的類別名稱必須事先指定好該類別下所擁有的屬性以及其屬性值是為何，否則會因為無法找到對應的類別名稱而設定預設樣式。</p>
<h2 id="Node-Attribute-style"><a href="#Node-Attribute-style" class="headerlink" title="Node-Attribute: style"></a>Node-Attribute: style</h2><p>style是元素節點的屬性之一，用來表示目前對應網頁標籤元素在style所定義的屬性值，style會使用CSSStyleDeclaration 物件(註2)來儲存對應的HTML標籤上所擁有的style屬性，舉一個例子，在span標籤下設定style屬性來證明元素節點下的style值會跟標籤的style值是一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color: red;background: blanchedalmond;&quot;&gt;My Website&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>那麼在元素節點下的style內容會是：從右半邊console去抓取span標籤元素，並且利用cssText(註3)來方便觀察元素節點下的style內容會是什麼，而左半邊的紅色字體正是用span標籤元素來呈現。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630158193/blog/dom_Manipulation/styleExample_ptjfbo.png"></p>
<p>從結果可以發現元素節點的style值會跟標籤下的style屬性是一致的。另外若把標籤下的style去掉的話，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;My Website&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>其結果會是：右半邊顯示的style是因為對應標籤的style內容不存在而變成空字串，而左半邊的span標籤元素則回到預設的樣式。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630158193/blog/dom_Manipulation/noStyleExample_unvazz.png"></p>
<p>從這兩個例子可以明顯看出標籤和元素節點下的style值都是一樣的且保持著同步。另外由DOMTokenList物件擁有著對應元素所能夠設定的樣式屬性名稱，比如字體大小、字體顏色、背景顏色等等，這些屬性名稱皆是該物件的屬性，可以藉由這個特性來設定特定的樣式屬性值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE.style.styleName: styleValue</span><br></pre></td></tr></table></figure>

<p>當然，當你透過上面方法來更動樣式屬性名稱時，便是代表連動更新元素節點下的style值以及標籤元素下的style值。</p>
<h2 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h2><ol>
<li>DOMTokenList物件是類似於陣列的物件但又不是陣列，儲存該物件的元素皆會以index做為綁定，可以透過index來存取對應元素。</li>
<li>CSSStyleDeclaration 物件是key-value pair的集合，其中key是元素會用到的樣式屬性名稱，而value則是對應的屬性值。</li>
<li>cssText 是 CSSStyleDeclaration 物件的屬性，只會回傳原本在對應的HTML標籤所擁有的style屬性值。</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li>DOMTokenList，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList">https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList</a></li>
<li>Element.classList，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList">https://developer.mozilla.org/en-US/docs/Web/API/Element/classList</a></li>
<li>CSSStyleDeclaration，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration">https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration</a></li>
<li>NODE.style，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style">https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/27/DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/27/DOM/" class="post-title-link" itemprop="url">DOM - 節點的構造</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-27 19:33:10" itemprop="dateCreated datePublished" datetime="2021-08-27T19:33:10+08:00">2021-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Website-Development/" itemprop="url" rel="index"><span itemprop="name">Website Development</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DOM (Document(註1) Object Model)是將HTML檔案本身內容轉化多個物件或者多個節點，並將這些物件&#x2F;節點組合成樹狀結構。每一個節點(Tag 1)都帶有一些子節點來表示對應元素的HTML屬性值(id和class)、文字內容、原本對應元素在HTML所包含的元素&#x2F;節點(tag，帶有其他子節點的節點或者帶有子節點集合的標籤):</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1633109630/blog/dom/aDomNode_x6bv3g.png"></p>
<p>在這裡只有類別名稱和特定ID並不會真的在DOM被當作子節點來看待，其餘元素則會按照parent-child關係來區分父節點和子節，因此我們可以將其餘元素視為該元素下的子節點(Child node1~Child nodeN)，而被對應元素包含的對應元素(Tag 2)也會是該節點下的子節點。</p>
<p>另外我們也根據節點的用途來進一步區分每個節點的種類是為何：</p>
<ul>
<li>若是HTML元素的話，會被當作是元素節點(Element Node)</li>
<li>若是代表元素的屬性(註2)，會被當作是屬性節點(Attribute Node)</li>
<li>若是代表一般的文字內容(本身並無特別意義)，會被當作是文字節點(Text Node)</li>
<li>若是代表HTML檔案上的註解內容，會被當作是註解節點(Comment Node)</li>
</ul>
<p>以一個例子來說明一個元素(標籤)在DOM中會是什麼樣子，在這裡我們以p標籤為例子，並給予p標籤一些屬性值，比如class和id，另外再讓p標籤去包含一般文字、em元素、註解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">	&lt;title&gt;DOM&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">	&lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">  	&lt;p class=&quot;class1 class2&quot; id=&quot;id1&quot;&gt;</span><br><span class="line">		&lt;!-- TEST COMMENT --&gt;</span><br><span class="line">    		This is a &lt;em&gt;simple&lt;/em&gt; website.</span><br><span class="line"> 	&lt;/p&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>經過瀏覽器解析而轉換成DOM後，其p標籤會如同下圖那樣，標籤以及被包含的標籤會被當作元素節點(以橘紅色來標示)，原本標籤上的屬性值會是屬性節點(以藍綠色來標示)，而子節點出現順序將會以HTML檔案的讀取順序來決定，越先讀取的就放的越前面，首先我們會看到由”TEST COMMENT”所構成的註解節點(以綠色來標示)，接著就是以”This is a “所構成的文字節點，緊接著是<em>元素節點，最後是” website.”構成的文字節點(以淺藍色來標示)，而<em>元素節點還會包含著”simple”所構成的文字節點(以橘紅色來標示):</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630055616/blog/dom/aDomNodeExample_ncvwwt.png"></p>
<h2 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h2><ol>
<li>Document Object Model中的Document是指HTML檔案本身</li>
<li>在HTML語法中，除了可以用<tag></tag>來定義其tag對應的元素以外，還可以在括號內部增加屬性值，來進一步描述其元素在HTML會呈現的樣子，而該屬性值包含了class、id、href、src等等，這些屬性值將會在DOM架構中被當作屬性節點。</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li>children 和 childNodes 的差別，<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/what-is-the-difference-between-children-and-childnodes-in-javascript/">https://www.geeksforgeeks.org/what-is-the-difference-between-children-and-childnodes-in-javascript/</a></li>
<li>HTML 屬性，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes">https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/27/RP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/27/RP/" class="post-title-link" itemprop="url">Rendering Path (一) 簡介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-27 00:01:22" itemprop="dateCreated datePublished" datetime="2021-08-27T00:01:22+08:00">2021-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:36" itemprop="dateModified" datetime="2022-03-18T00:06:36+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Website-Development/" itemprop="url" rel="index"><span itemprop="name">Website Development</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="渲染路徑簡介"><a href="#渲染路徑簡介" class="headerlink" title="渲染路徑簡介"></a>渲染路徑簡介</h2><p>Rendering Path 是瀏覽器如何將網頁檔案轉化成網頁的處理路徑，其路徑包含了網路(Network)、HTML、CSS檔案轉化成兩顆獨立樹狀結構、兩顆樹狀結構合併成渲染樹(Render Tree)、版面配置(Layout)、繪製(Paint)，每個路徑之間關係會如同下圖所示那樣，首先會先從網路找到提供網頁的伺服器獲取對應網頁(由HTML、CSS)、當客戶端的瀏覽器一拿到這些檔案，便會將他們轉化為名為 DOM Tree 和 CSSOM Tree，接著再將兩顆樹合併成渲染樹，接著根據渲染樹和DOM Tree來計算網頁上的每個元件的實際擺放位置以及大小，最後再用瀏覽器的繪製方法來完整呈現每一個元件的真實面貌，比如輪廓、顏色之類的。在本文會談論到路徑上會包含到的東西，但比較偏重於Network至Layout之間的東西，剩下將由後續的文章進行補充，因此而將本文歸類為(一)。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629987931/blog/RenderingPath/Critical_Rendering_Path_ntcjvi.png"></p>
<h2 id="網路"><a href="#網路" class="headerlink" title="網路"></a>網路</h2><p>當使用者開始透過URL來瀏覽網頁時，瀏覽器會先試著解析URL對應的IP是誰，唯有知道IP是哪個伺服器負責提供對應的網頁服務才能進行網頁的相關處理以及向誰發送”要求網頁檔案回傳過來”的請求。</p>
<p>而解析URL的流程主要流程為：</p>
<ul>
<li>檢查瀏覽器本身的快取(Cache)是否有URL的對應IP，若沒有則繼續朝下一個目標找</li>
<li>檢查(執行目前的瀏覽器)作業系統的快取(Cache)是否有URL的對應IP，若沒有則繼續朝下一個目標</li>
<li>檢查離本地端較近的路由器(Router)是否有URL的對應IP，沒有朝下一個目標找</li>
<li>對ISP發送請求詢問它那邊的快取是否有對應IP，沒有朝下一個目標找</li>
<li>就開始針對ISP的DNS Server進行遞迴式搜查，直到找到對應IP</li>
</ul>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629970812/blog/RenderingPath/howtofindIP_pku1yw.png"></p>
<p>不論流程會如何處理，最後結果只會有對應的IP和不存在對應IP的訊息，在這裡只探討前者，當瀏覽器已經得知對應IP是什麼，那麼使用者(瀏覽器)會再重新對該IP來要求伺服器回傳網頁的對應檔(包含了HTML檔案、CSS檔案、JavaScript檔案)給使用者的瀏覽器，而回傳檔案的形式並不會一口氣以一個完整檔案傳過去，而是以固定大小的封包(Packet)形式將原檔案切分成好幾等分傳給使用者的瀏覽器來處理。</p>
<h2 id="HTML-轉化成-DOM-Tree"><a href="#HTML-轉化成-DOM-Tree" class="headerlink" title="HTML 轉化成 DOM Tree"></a>HTML 轉化成 DOM Tree</h2><p>當瀏覽器收到HTML檔案被切分出來的封包時，瀏覽器不會直接等待完整檔案被拼湊出來，而是邊收邊將收到的內容按照DOM形式來建立一個DOM節點，每一個節點都各代表一個獨立的內容或者對應標籤，當一個節點A對應原HTML檔案的標籤或者內容是在另一個節點B對應的標籤內部的話，那麼這個節點A會根據內部的深度來決定是否為節點B的子節點(Child Node)？還是為節點B的後代節點(Descendant Node)，比如說節點A對應的標籤是elementA，而節點B的標籤是elementB，若elementA還被其他元素包含著，那麼節點A就會是節點B的後代節點</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;elementB&gt;</span><br><span class="line">  &lt;otherElement&gt;</span><br><span class="line">      &lt;elementA&gt;&lt;/elementA&gt;</span><br><span class="line">  &lt;/otherElement&gt;</span><br><span class="line">&lt;/elementB&gt;</span><br></pre></td></tr></table></figure>

<p>但若elementA沒被其他元素包含著，那麼節點A就會是節點B的子節點</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;elementB&gt;</span><br><span class="line">  &lt;elementA&gt;&lt;/elementA&gt;</span><br><span class="line">&lt;/elementB&gt;</span><br></pre></td></tr></table></figure>
<p>最後由這些節點的生成以及如何連接來構成一個樹狀結構，該樹狀結構被稱之為DOM Tree，在這個樹狀結構中會有代表HTML標籤(元件)的元素節點、代表其元件屬性的屬性節點、代表一般文字內容的文字節點以及代表註解內容的註解節點等。</p>
<p>拿下面的HTML程式碼來當例子的話：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line"> 	  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">	&lt;h1&gt;This is an example&lt;/h1&gt;</span><br><span class="line">  	&lt;p&gt;Critical Rendering Path&lt;/p&gt;</span><br><span class="line">	&lt;label&gt;Hello World&lt;/label&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在解析的過程中，會被轉化為以下樹狀結構，首先html標籤會先被瀏覽器擷取來建立一個獨立的DOM節點，接著再讀取到head標籤時，由於它是位於html標籤內部且沒其他標籤包含著，所以它會被設定成html標籤對應節點的子節點並且被html對應節點連接著，而link對應節點會因為這樣被設定成head標籤對應節點的子節點，而後body、h1、p、label也皆因為這樣而與其他節點進行連接，最後形成以下結果：<br><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629973153/blog/RenderingPath/domTreeExample_ep0cvp.png"></p>
<h2 id="CSS-轉化成-CSSOM-Tree"><a href="#CSS-轉化成-CSSOM-Tree" class="headerlink" title="CSS 轉化成 CSSOM Tree"></a>CSS 轉化成 CSSOM Tree</h2><p>當瀏覽器收到CSS檔案被切分出來的封包時，瀏覽器會直接等待整個CSS檔案拼湊出來才開始解析，這是因為CSS屬性很容易被後續接收到的內容給覆蓋掉，甚至造成結構性的改變，所以必須等待封包組裝成一份完整的CSS檔案才開始解析，當開始解析時，由於 HTML 轉化成 DOM Tree 的過程很有可能因為邊接收邊處理而有初步產生的 DOM Tree，根據樹狀結構再將樣式表對應的標籤與樹狀結構中對應標籤的節點進行綁定，也就是說在CSSOM Tree會以DOM Tree為雛形，並且再將對應的樣式附加至每個對應元件的節點，而這個樹狀結構被稱之為CSSOM，在這樹狀結構中，只會出現代表HTML元件的元素節點。</p>
<p>若以上面為例子來建立特定CSS樣式的話，其內容會是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    padding: 5%;</span><br><span class="line">    font-size: 2vw;</span><br><span class="line">    border: 2px solid #000;</span><br><span class="line">    color: #308D46;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">   text-align: center;</span><br><span class="line">   font-size: 10vw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">label &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629982746/blog/RenderingPath/cssomTreeExample_lbkboi.png"></p>
<h3 id="產生DOM之後的JavaScript"><a href="#產生DOM之後的JavaScript" class="headerlink" title="產生DOM之後的JavaScript"></a>產生DOM之後的JavaScript</h3><p>在產生DOM和CSSOM之後，我們還可以透過JavaScript在Render Tree產生之前來變更DOM或者CSSOM的內容，假設一個HTML檔案內容為以下內容，後頭有個script包覆著的內容，其內容會是JavaScript的語法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;h1&gt;hi world&lt;/h1&gt;</span><br><span class="line">        &lt;h3&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            document.getElementsByTagName(&quot;h3&quot;)[0].innerHTML = &quot;a123&quot;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而其內容是變更原本沒內容的h3標籤元素：在這裡你可以看到內容會被指定為”a123”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(&quot;h3&quot;)[0].innerHTML = &quot;a123&quot;</span><br></pre></td></tr></table></figure>

<p>而當我們以瀏覽器來讀取整份檔案時，會在DOM Tree裡發現h3標籤元素所儲存的內容變更為”a123”，不再是無內容，從這邊展現出JavaScript可以在合併前影響著DOM和CSSOM</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629989767/blog/RenderingPath/result_javascript_within__html_ijz2jg.png"></p>
<p>若script部分程式碼是擺在h3元素定義之前的話，其script執行的結果會是無法改變h3元素內容。</p>
<h2 id="渲染樹"><a href="#渲染樹" class="headerlink" title="渲染樹"></a>渲染樹</h2><p>在經過解析後從而獲得DOM以及CSSOM之後，接著會根據兩者對應的元件是否一樣來進行同元件在DOM和CSSOM的節點合併，合併後的節點會以DOM節點的形式多增加一個子節點(如同下圖紅框中的節點)來表示父節點(網頁元素)要調整的樣式是為何。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629991053/blog/RenderingPath/newNode_renderTree_otmzal.png"></p>
<p>另外會根據該元素是否能夠正常在瀏覽器顯示來決定該元素是否存在於Render Tree，也就是說當元素本身設定為display: none的屬性時，該元素不會在這個階段挑選為合併後的結果，預設上有這設定的元素有html、head、link、body等元素，所以在合併結果上並不會看到它們。</p>
<p>我們繼續拿DOM和CSS提到的例子來為他們合併成一個Render Tree，在這裡你可以看到叉叉，而它表示著其元素本身是display: none的元素，所以無法成為最終合併後的結果，另外也由於body元素也被跟著剔除，所以會在最終結果上替合併後的新樹添加新的root元素，而在那下的每個節點都會有新加進來的屬性節點，這些節點會在後續paint程序為父節點增添樣式。</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629992018/blog/RenderingPath/renderTreeExample_lnh9md.png"></p>
<p>最後的合併結果會是：</p>
<p><img src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1629992416/blog/RenderingPath/finalRenderTreeExample_sf7ylt.png"></p>
<h2 id="版面配置和繪製"><a href="#版面配置和繪製" class="headerlink" title="版面配置和繪製"></a>版面配置和繪製</h2><p>在版面配置中會利用前面階段獲取的樹狀結構來計算網頁元件實際會在頁面上擺放的位置、大小以及如何擺放，計算完之後便會跳到下一個階段-繪製，繪製過程會開始依據渲染樹指定的樣式來對頁面上的pixel來呈現每個元件的真實面貌，比如背景顏色、背景圖片、邊框、輪廓等等，過程中會遍歷著渲染樹並對著指定元件在特定螢幕位置進行無數次(由render&#x2F;瀏覽器所提供)paint的呼叫來實際達成元件的呈現。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://dev.to/deepika_banoth/what-happens-when-i-type-a-url-in-browser-3i5o">瀏覽器如何處理解析URL</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/critical-rendering-path-flow/">什麼是Critical Rendering Path</a></li>
<li><a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Painting">瀏覽器如何處理網頁</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/11/inlineVsBlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/11/inlineVsBlock/" class="post-title-link" itemprop="url">Inline element VS. Block element</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-11 23:31:19" itemprop="dateCreated datePublished" datetime="2021-08-11T23:31:19+08:00">2021-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:35" itemprop="dateModified" datetime="2022-03-18T00:06:35+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Website-Development/" itemprop="url" rel="index"><span itemprop="name">Website Development</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="inline-element"><a href="#inline-element" class="headerlink" title="inline element"></a>inline element</h2><p>容器會以實際容器所存的內容為主且不會特別佔據沒顯示內容的區塊而將容器特別獨立開來，以此特性會讓該容器能夠與其他容器在同一行內呈現，而inline element就是由此而得名。</p>
<p>特點：</p>
<ol>
<li>容器的範圍會貼齊實際內容，也就是說容器內並不會出現額外的空白</li>
<li>容器會以內容為主，並不能夠隨意調整高度和寬度</li>
<li>容器在網頁上的呈現並不會在新的一行呈現，會貼齊上個容器後</li>
</ol>
<h2 id="block-element"><a href="#block-element" class="headerlink" title="block element"></a>block element</h2><p>該容器會以特定的高寬度來製作以及使用足夠大的margin來與其他容器隔開來，這並不像inline那樣會貼齊內容製作，所以容器內部本身會夾雜著除了主要內容以外的空白，且本身會用margin來隔開其他容器，所以會呈現上會是新的一行來呈現，並不會與其他容器在同一行呈現。</p>
<p>特點：</p>
<ol>
<li>容器的範圍並不會貼齊實際內容，也就是說容器內很有可能會出現額外的空白</li>
<li>容器可以隨意調整高度和寬度</li>
<li>容器在網頁上的呈現會在新的一行出現，並不會貼齊上個容器後</li>
</ol>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/difference-between-block-elements-and-inline-elements/">https://www.geeksforgeeks.org/difference-between-block-elements-and-inline-elements/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/inline-elements-and-block-elements-in-html-explained/">https://www.freecodecamp.org/news/inline-elements-and-block-elements-in-html-explained/</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/11/distanceOfTwoPoints/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/11/distanceOfTwoPoints/" class="post-title-link" itemprop="url">CodeWars Learning - Geometry Basics &#58; Distance between points in 2D</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-11 16:20:31" itemprop="dateCreated datePublished" datetime="2021-08-11T16:20:31+08:00">2021-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:34" itemprop="dateModified" datetime="2022-03-18T00:06:34+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CodeWars/" itemprop="url" rel="index"><span itemprop="name">CodeWars</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>This series of katas will introduce you to basics of doing geometry with computers.</p>
<p>Point objects have x and y attributes (X and Y in C#) attributes.</p>
<p>Write a function calculating distance between Point a and Point b.</p>
<p>Tests round answers to 6 decimal places.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由於傳過來的輸入參數a和b皆為擁有x和y這兩個屬性的物件，所以只需要計算x座標軸的值和y座標軸的值，最後再透過兩點的距離公式來獲取兩點的距離。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function distanceBetweenPoints(a, b) &#123;</span><br><span class="line"></span><br><span class="line">  let xAxis = Math.abs(a.x - b.x)</span><br><span class="line">  let yAxis = Math.abs(a.y - b.y)</span><br><span class="line">  </span><br><span class="line">  return Math.sqrt(Math.pow(xAxis, 2) + Math.pow(yAxis, 2))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一個版本的答案則是使用Math物件的內建方法hypot，以a點和b點來構成三角形並求得這三角形的斜邊長度(hypotenuse)，而這個長度剛好是這兩點的距離。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function distanceBetweenPoints(a, b) &#123;</span><br><span class="line">  return Math.hypot(a.x - b.x, a.y - b.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eklipsorz.github.io/2021/08/11/bool2String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
      <meta itemprop="name" content="Eklipsorz">
      <meta itemprop="description" content="Success is nothing more than a few simple disciplines, practiced every day.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sloth Engineer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/11/bool2String/" class="post-title-link" itemprop="url">CodeWars Learning - Convert boolean values to strings 'Yes' or 'No'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-11 16:15:45" itemprop="dateCreated datePublished" datetime="2021-08-11T16:15:45+08:00">2021-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:06:33" itemprop="dateModified" datetime="2022-03-18T00:06:33+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CodeWars/" itemprop="url" rel="index"><span itemprop="name">CodeWars</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Complete the method that takes a boolean value and return a “Yes” string for true, or a “No” string for false.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>設定一個條件式來轉換true或者false就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function boolToWord( bool )&#123;</span><br><span class="line">  return bool === true ? &#x27;Yes&#x27; : &#x27;No&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Eklipsorz"
      src="https://res.cloudinary.com/dqfxgtyoi/image/upload/v1632402033/blog/medium_brown-throated-sloth-Nortondefeis-toned-2160x1827_zz1pai.jpg">
  <p class="site-author-name" itemprop="name">Eklipsorz</p>
  <div class="site-description" itemprop="description">Success is nothing more than a few simple disciplines, practiced every day.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eklipsorz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eklipsorz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eklipsorz@protonmail.ch" title="E-Mail → mailto:eklipsorz@protonmail.ch" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eklipsorz</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
